// Generated by CoffeeScript 1.6.2
(function() {
  var Visualizer;

  Visualizer = (function($, window, undefined_) {
    var Arc, Chunk, DocumentData, EventDesc, Fragment, Measurements, Row, Span, fontLoadTimeout, proceedWithFonts, sentenceSplit, setCollectionDefaults, setSourceDataDefaults, tokenise;

    fontLoadTimeout = 1;
    DocumentData = function(text) {
      this.text = text;
      this.chunks = [];
      this.spans = {};
      this.eventDescs = {};
      this.sentComment = {};
      this.arcs = [];
      this.arcById = {};
      this.markedSent = {};
      this.spanAnnTexts = {};
      return this.towers = {};
    };
    Fragment = function(id, span, from, to) {
      this.id = id;
      this.span = span;
      this.from = from;
      return this.to = to;
    };
    Span = function(id, type, offsets, generalType) {
      this.id = id;
      this.type = type;
      this.totalDist = 0;
      this.numArcs = 0;
      this.generalType = generalType;
      this.headFragment = null;
      this.unsegmentedOffsets = offsets;
      this.offsets = [];
      this.segmentedOffsetsMap = {};
      return this.initContainers();
    };
    Span.prototype.initContainers = function(offsets) {
      this.incoming = [];
      this.outgoing = [];
      this.attributes = {};
      this.attributeText = [];
      this.attributeCues = {};
      this.attributeCueFor = {};
      this.attributeMerge = {};
      this.fragments = [];
      return this.normalizations = [];
    };
    Span.prototype.splitMultilineOffsets = function(text) {
      var begin, c, end, fi, nfi, ti, _results;

      this.segmentedOffsetsMap = {};
      fi = 0;
      nfi = 0;
      _results = [];
      while (fi < this.unsegmentedOffsets.length) {
        begin = this.unsegmentedOffsets[fi][0];
        end = this.unsegmentedOffsets[fi][1];
        ti = begin;
        while (ti < end) {
          c = text.charAt(ti);
          if (c === "\n" || c === "\r") {
            if (begin !== null) {
              this.offsets.push([begin, ti]);
              this.segmentedOffsetsMap[nfi++] = fi;
              begin = null;
            }
          } else {
            if (begin === null) {
              begin = ti;
            }
          }
          ti++;
        }
        if (begin !== null) {
          this.offsets.push([begin, end]);
          this.segmentedOffsetsMap[nfi++] = fi;
        }
        _results.push(fi++);
      }
      return _results;
    };
    Span.prototype.copy = function(id) {
      var span;

      span = $.extend(new Span(), this);
      span.id = id;
      span.initContainers();
      span.unsegmentedOffsets = this.unsegmentedOffsets.slice();
      span.offsets = this.offsets;
      span.segmentedOffsetsMap = this.segmentedOffsetsMap;
      return span;
    };
    EventDesc = function(id, triggerId, roles, klass) {
      var roleList;

      this.id = id;
      this.triggerId = triggerId;
      roleList = this.roles = [];
      $.each(roles, function(roleNo, role) {
        return roleList.push({
          type: role[0],
          targetId: role[1]
        });
      });
      if (klass === "equiv") {
        return this.equiv = true;
      } else {
        if (klass === "relation") {
          return this.relation = true;
        }
      }
    };
    Chunk = function(index, text, from, to, space, spans) {
      this.index = index;
      this.text = text;
      this.from = from;
      this.to = to;
      this.space = space;
      return this.fragments = [];
    };
    Arc = function(eventDesc, role, dist, eventNo) {
      this.origin = eventDesc.id;
      this.target = role.targetId;
      this.dist = dist;
      this.type = role.type;
      this.shadowClass = eventDesc.shadowClass;
      this.jumpHeight = 0;
      if (eventDesc.equiv) {
        this.equiv = true;
        this.eventDescId = eventNo;
        return eventDesc.equivArc = this;
      } else if (eventDesc.relation) {
        this.relation = true;
        return this.eventDescId = eventNo;
      }
    };
    Row = function(svg) {
      this.group = svg.group();
      this.background = svg.group(this.group);
      this.chunks = [];
      this.hasAnnotations = false;
      this.maxArcHeight = 0;
      return this.maxSpanHeight = 0;
    };
    Measurements = function(widths, height, y) {
      this.widths = widths;
      this.height = height;
      return this.y = y;
    };
    tokenise = function(text) {
      var c, i, lastCharPos, tokenOffsets, tokenStart;

      tokenOffsets = [];
      tokenStart = null;
      lastCharPos = null;
      i = 0;
      while (i < text.length) {
        c = text[i];
        if ((tokenStart == null) && !/\s/.test(c)) {
          tokenStart = i;
          lastCharPos = i;
        } else if (/\s/.test(c) && (tokenStart != null)) {
          tokenOffsets.push([tokenStart, i]);
          tokenStart = null;
        } else {
          if (!/\s/.test(c)) {
            lastCharPos = i;
          }
        }
        i++;
      }
      if (tokenStart != null) {
        tokenOffsets.push([tokenStart, lastCharPos + 1]);
      }
      return tokenOffsets;
    };
    sentenceSplit = function(text) {
      var c, i, lastCharPos, sentStart, sentenceOffsets;

      sentenceOffsets = [];
      sentStart = null;
      lastCharPos = null;
      i = 0;
      while (i < text.length) {
        c = text[i];
        if ((sentStart == null) && !/\s/.test(c)) {
          sentStart = i;
          lastCharPos = i;
        } else if (c === "\n" && (sentStart != null)) {
          sentenceOffsets.push([sentStart, i]);
          sentStart = null;
        } else {
          if (!/\s/.test(c)) {
            lastCharPos = i;
          }
        }
        i++;
      }
      if (sentStart != null) {
        sentenceOffsets.push([sentStart, lastCharPos + 1]);
      }
      return sentenceOffsets;
    };
    setSourceDataDefaults = function(sourceData) {
      $.each(["attributes", "comments", "entities", "equivs", "events", "modifications", "normalizations", "relations", "triggers"], function(attrNo, attr) {
        if (sourceData[attr] === undefined) {
          return sourceData[attr] = [];
        }
      });
      if (sourceData.sentence_offsets === undefined) {
        sourceData.sentence_offsets = sentenceSplit(sourceData.text);
      }
      if (sourceData.token_offsets === undefined) {
        return sourceData.token_offsets = tokenise(sourceData.text);
      }
    };
    setCollectionDefaults = function(collectionData) {
      return $.each(["entity_attribute_types", "entity_types", "event_attribute_types", "event_types", "relation_attribute_types", "relation_types", "unconfigured_types"], function(attrNo, attr) {
        if (collectionData[attr] === undefined) {
          return collectionData[attr] = [];
        }
      });
    };
    Visualizer = function(dispatcher, svgId, webFontURLs) {
      var $svg, $svgDiv, addArcTextMeasurements, addHeaderAndDefs, adjustFragmentHeights, adjustTowerAnnotationSizes, arcHorizontalSpacing, arcLabelShadowRounding, arcLabelShadowSize, arcSlant, args, boxTextMargin, clearSVG, coll, collapseArcSpace, collapseArcs, collectionChanged, collectionLoaded, coloredCurlies, commentId, commentPrioLevels, commentPriority, data, doc, drawing, entityAttributeTypes, eventAttributeTypes, findArcHeight, forceRedraw, fragmentComparator, fragmentConnectorColor, fragmentConnectorDashArray, getTextAndSpanTextMeasurements, getTextMeasurements, gotCurrent, highlight, highlightArcSequence, highlightArcs, highlightDuration, highlightGroup, highlightMatchSequence, highlightRounding, highlightSequence, highlightSpanSequence, highlightSpans, highlightTextSequence, isCollectionLoaded, isReloadOkay, isRenderRequested, loadAttributeTypes, loadRelationTypes, loadSpanTypes, makeArrow, markedArcSize, markedArcStroke, markedSpanSize, minArcSlant, nestingAdjustXStepSize, nestingAdjustYStepSize, onMouseOut, onMouseOver, rectShadowRounding, rectShadowSize, redraw, registerHandlers, relationTypesHash, renderData, renderDataReal, renderDocument, renderErrors, requestRenderData, requestedData, resetData, reverseArcControlx, roundCoordinates, rowBBox, rowPadding, rowSpacing, sentNumMargin, setAbbrevs, setData, setLayoutDensity, setMarked, setSvgWidth, setTextBackgrounds, shadowStroke, showMtime, smoothArcCurves, smoothArcSteepness, sourceData, spaceWidths, spanTypes, svg, that, translate, triggerRender, webFontConfig;

      $svgDiv = $("#" + svgId);
      if (!$svgDiv.length) {
        throw Error("Could not find container with id=\"" + svgId + "\"");
      }
      that = this;
      roundCoordinates = true;
      boxTextMargin = {
        x: 0,
        y: 1.5
      };
      highlightRounding = {
        x: 3,
        y: 3
      };
      spaceWidths = {
        " ": 4,
        "ï¿½": 4,
        " ": 0,
        " ": 8,
        "\n": 4
      };
      coloredCurlies = true;
      arcSlant = 15;
      minArcSlant = 8;
      arcHorizontalSpacing = 10;
      rowSpacing = -5;
      sentNumMargin = 20;
      smoothArcCurves = true;
      smoothArcSteepness = 0.5;
      reverseArcControlx = 5;
      rectShadowSize = 3;
      rectShadowRounding = 2.5;
      arcLabelShadowSize = 1;
      arcLabelShadowRounding = 5;
      shadowStroke = 2.5;
      markedSpanSize = 6;
      markedArcSize = 2;
      markedArcStroke = 7;
      rowPadding = 2;
      nestingAdjustYStepSize = 2;
      nestingAdjustXStepSize = 1;
      highlightSequence = "#FF9632;#FFCC00;#FF9632";
      highlightSpanSequence = highlightSequence;
      highlightArcSequence = highlightSequence;
      highlightTextSequence = highlightSequence;
      highlightDuration = "2s";
      highlightMatchSequence = "#FFFF00";
      fragmentConnectorDashArray = "1,3,3,3";
      fragmentConnectorColor = "#000000";
      svg = void 0;
      $svg = void 0;
      data = null;
      sourceData = null;
      requestedData = null;
      coll = void 0;
      doc = void 0;
      args = void 0;
      relationTypesHash = void 0;
      isRenderRequested = void 0;
      isCollectionLoaded = false;
      entityAttributeTypes = null;
      eventAttributeTypes = null;
      spanTypes = null;
      highlightGroup = void 0;
      collapseArcs = true;
      collapseArcSpace = false;
      commentPrioLevels = ["Unconfirmed", "Incomplete", "Warning", "Error", "AnnotatorNotes", "AddedAnnotation", "MissingAnnotation", "ChangedAnnotation"];
      this.arcDragOrigin = null;
      forceRedraw = function() {
        if (!$.browser.chrome) {
          return;
        }
        $svg.css("margin-bottom", 1);
        return setTimeout((function() {
          return $svg.css("margin-bottom", 0);
        }), 0);
      };
      rowBBox = function(span) {
        var box, chunkTranslation;

        box = $.extend({}, span.rectBox);
        chunkTranslation = span.chunk.translation;
        box.x += chunkTranslation.x;
        box.y += chunkTranslation.y;
        return box;
      };
      commentPriority = function(commentClass) {
        var i, len;

        if (commentClass === undefined) {
          return -1;
        }
        len = commentPrioLevels.length;
        i = 0;
        while (i < len) {
          if (commentClass.indexOf(commentPrioLevels[i]) !== -1) {
            return i;
          }
          i++;
        }
        return 0;
      };
      clearSVG = function() {
        data = null;
        sourceData = null;
        svg.clear();
        return $svgDiv.hide();
      };
      setMarked = function(markedType) {
        return $.each(args[markedType] || [], function(markedNo, marked) {
          var eventDesc, relArc, span;

          if (marked[0] === "sent") {
            return data.markedSent[marked[1]] = true;
          } else if (marked[0] === "equiv") {
            return $.each(sourceData.equivs, function(equivNo, equiv) {
              var arc, i, len;

              if (equiv[1] === marked[1]) {
                len = equiv.length;
                i = 2;
                while (i < len) {
                  if (equiv[i] === marked[2]) {
                    len -= 3;
                    i = 1;
                    while (i <= len) {
                      arc = data.eventDescs[equiv[0] + "*" + i].equivArc;
                      arc.marked = markedType;
                      i++;
                    }
                    return;
                  }
                  i++;
                }
              }
            });
          } else if (marked.length === 2) {
            return markedText.push([parseInt(marked[0], 10), parseInt(marked[1], 10), markedType]);
          } else {
            span = data.spans[marked[0]];
            if (span) {
              if (marked.length === 3) {
                return $.each(span.outgoing, function(arcNo, arc) {
                  if (arc.target === marked[2] && arc.type === marked[1]) {
                    return arc.marked = markedType;
                  }
                });
              } else {
                return span.marked = markedType;
              }
            } else {
              eventDesc = data.eventDescs[marked[0]];
              if (eventDesc) {
                relArc = eventDesc.roles[0];
                return $.each(data.spans[eventDesc.triggerId].outgoing, function(arcNo, arc) {
                  if (arc.target === relArc.targetId && arc.type === relArc.type) {
                    return arc.marked = markedType;
                  }
                });
              } else {
                return $.each(data.eventDescs, function(eventDescNo, eventDesc) {
                  if (eventDesc.triggerId === marked[0]) {
                    return data.spans[eventDesc.id].marked = markedType;
                  }
                });
              }
            }
          }
        });
      };
      findArcHeight = function(fromIndex, toIndex, fragmentHeights) {
        var height, i;

        height = 0;
        i = fromIndex;
        while (i <= toIndex) {
          if (fragmentHeights[i] > height) {
            height = fragmentHeights[i];
          }
          i++;
        }
        height += Configuration.visual.arcSpacing;
        return height;
      };
      adjustFragmentHeights = function(fromIndex, toIndex, fragmentHeights, height) {
        var i, _results;

        i = fromIndex;
        _results = [];
        while (i <= toIndex) {
          if (fragmentHeights[i] < height) {
            fragmentHeights[i] = height;
          }
          _results.push(i++);
        }
        return _results;
      };
      fragmentComparator = function(a, b) {
        var aSpan, ad, bSpan, bd, tmp;

        tmp = void 0;
        aSpan = a.span;
        bSpan = b.span;
        tmp = aSpan.fragments.length - bSpan.fragments.length;
        if (tmp) {
          return (tmp < 0 ? 1 : -1);
        }
        tmp = aSpan.avgDist - bSpan.avgDist;
        if (tmp) {
          return (tmp < 0 ? -1 : 1);
        }
        tmp = aSpan.numArcs - bSpan.numArcs;
        if (tmp) {
          return (tmp < 0 ? -1 : 1);
        }
        ad = a.to - a.from;
        bd = b.to - b.from;
        tmp = ad - bd;
        if (aSpan.numArcs === 0 && bSpan.numArcs === 0) {
          tmp = -tmp;
        }
        if (tmp) {
          return (tmp < 0 ? 1 : -1);
        }
        tmp = aSpan.refedIndexSum - bSpan.refedIndexSum;
        if (tmp) {
          return (tmp < 0 ? -1 : 1);
        }
        if (aSpan.type < bSpan.type) {
          return -1;
        } else {
          if (aSpan.type > bSpan.type) {
            return 1;
          }
        }
        return 0;
      };
      setData = function(_sourceData) {
        var chunk, chunkNo, currentChunk, currentChunkId, currentFragmentId, firstFrom, i, lastFragment, lastTo, markedText, midpointComparator, numChunks, numFragments, pastFirst, sentenceNo, sortedFragments, space, spanAnnTexts, spanComparator, startChunk, startFragmentId, towerId, triggerHash;

        if (!args) {
          args = {};
        }
        sourceData = _sourceData;
        dispatcher.post("newSourceData", [sourceData]);
        data = new DocumentData(sourceData.text);
        $.each(sourceData.entities, function(entityNo, entity) {
          var span;

          span = new Span(entity[0], entity[1], entity[2], "entity");
          span.splitMultilineOffsets(data.text);
          return data.spans[entity[0]] = span;
        });
        triggerHash = {};
        $.each(sourceData.triggers, function(triggerNo, trigger) {
          var triggerSpan;

          triggerSpan = new Span(trigger[0], trigger[1], trigger[2], "trigger");
          triggerSpan.splitMultilineOffsets(data.text);
          return triggerHash[trigger[0]] = [triggerSpan, []];
        });
        $.each(sourceData.events, function(eventNo, eventRow) {
          var eventDesc, span, trigger;

          eventDesc = data.eventDescs[eventRow[0]] = new EventDesc(eventRow[0], eventRow[1], eventRow[2]);
          trigger = triggerHash[eventDesc.triggerId];
          span = trigger[0].copy(eventDesc.id);
          trigger[1].push(span);
          return data.spans[eventDesc.id] = span;
        });
        $.each(sourceData.modifications, function(modNo, mod) {
          if (!data.spans[mod[2]]) {
            dispatcher.post("messages", [[["<strong>ERROR</strong><br/>Event " + mod[2] + " (referenced from modification " + mod[0] + ") does not occur in document " + data.document + "<br/>(please correct the source data)", "error", 5]]]);
            return;
          }
          return data.spans[mod[2]][mod[1]] = true;
        });
        midpointComparator = function(a, b) {
          var tmp;

          tmp = a.from + a.to - b.from - b.to;
          if (!tmp) {
            return 0;
          }
          if (tmp < 0) {
            return -1;
          } else {
            return 1;
          }
        };
        $.each(data.spans, function(spanNo, span) {
          $.each(span.offsets, function(offsetsNo, offsets) {
            var fragment, from, to;

            from = parseInt(offsets[0], 10);
            to = parseInt(offsets[1], 10);
            fragment = new Fragment(offsetsNo, span, from, to);
            return span.fragments.push(fragment);
          });
          span.fragments.sort(midpointComparator);
          span.wholeFrom = span.fragments[0].from;
          span.wholeTo = span.fragments[span.fragments.length - 1].to;
          return span.headFragment = span.fragments[(true ? span.fragments.length - 1 : 0)];
        });
        spanComparator = function(a, b) {
          var aSpan, bSpan, tmp;

          aSpan = data.spans[a];
          bSpan = data.spans[b];
          tmp = aSpan.headFragment.from + aSpan.headFragment.to - bSpan.headFragment.from - bSpan.headFragment.to;
          if (tmp) {
            return (tmp < 0 ? -1 : 1);
          }
          return 0;
        };
        $.each(sourceData.equivs, function(equivNo, equiv) {
          var equivSpans, eventDesc, i, len, okEquivSpans, _results;

          equiv[0] = "*" + equivNo;
          equivSpans = equiv.slice(2);
          okEquivSpans = [];
          $.each(equivSpans, function(equivSpanNo, equivSpan) {
            if (data.spans[equivSpan]) {
              return okEquivSpans.push(equivSpan);
            }
          });
          okEquivSpans.sort(spanComparator);
          len = okEquivSpans.length;
          i = 1;
          _results = [];
          while (i < len) {
            eventDesc = data.eventDescs[equiv[0] + "*" + i] = new EventDesc(okEquivSpans[i - 1], okEquivSpans[i - 1], [[equiv[1], okEquivSpans[i]]], "equiv");
            eventDesc.leftSpans = okEquivSpans.slice(0, i);
            eventDesc.rightSpans = okEquivSpans.slice(i);
            _results.push(i++);
          }
          return _results;
        });
        $.each(sourceData.relations, function(relNo, rel) {
          var argsDesc, t1, t2;

          argsDesc = relationTypesHash[rel[1]];
          argsDesc = argsDesc && argsDesc.args;
          t1 = void 0;
          t2 = void 0;
          if (argsDesc) {
            args = {};
            args[rel[2][0][0]] = rel[2][0][1];
            args[rel[2][1][0]] = rel[2][1][1];
            t1 = args[argsDesc[0].role];
            t2 = args[argsDesc[1].role];
          } else {
            t1 = rel[2][0][1];
            t2 = rel[2][1][1];
          }
          return data.eventDescs[rel[0]] = new EventDesc(t1, t1, [[rel[1], t2]], "relation");
        });
        $.each(sourceData.attributes, function(attrNo, attr) {
          var attrText, attrType, attrValue, cueSpan, span, valText;

          attrType = eventAttributeTypes[attr[1]] || entityAttributeTypes[attr[1]];
          attrValue = attrType && attrType.values[attrType.bool || attr[3]];
          span = data.spans[attr[2]];
          if (!span) {
            dispatcher.post("messages", [[["Annotation " + attr[2] + ", referenced from attribute " + attr[0] + ", does not exist.", "error"]]]);
            return;
          }
          valText = (attrValue && attrValue.name) || attr[3];
          attrText = (attrType ? (attrType.bool ? attrType.name : attrType.name + ": " + valText) : (attr[3] === true ? attr[1] : attr[1] + ": " + attr[3]));
          span.attributeText.push(attrText);
          span.attributes[attr[1]] = attr[3];
          if (attr[4]) {
            span.attributeCues[attr[1]] = attr[4];
            cueSpan = data.spans[attr[4]];
            cueSpan.attributeCueFor[data.spans[1]] = attr[2];
            cueSpan.cue = "CUE";
          }
          return $.extend(span.attributeMerge, attrValue);
        });
        $.each(sourceData.comments, function(commentNo, comment) {
          var commentEntities, eventDesc, id, sent, text, trigger;

          if (comment[0] instanceof Array && comment[0][0] === "sent") {
            sent = comment[0][1];
            text = comment[2];
            if (data.sentComment[sent]) {
              text = data.sentComment[sent].text + "<br/>" + text;
            }
            return data.sentComment[sent] = {
              type: comment[1],
              text: text
            };
          } else {
            id = comment[0];
            trigger = triggerHash[id];
            eventDesc = data.eventDescs[id];
            commentEntities = (trigger ? trigger[1] : (id in data.spans ? [data.spans[id]] : (id in data.eventDescs ? [data.eventDescs[id]] : [])));
            return $.each(commentEntities, function(entityId, entity) {
              if (!entity.comment) {
                entity.comment = {
                  type: comment[1],
                  text: comment[2]
                };
              } else {
                entity.comment.type = comment[1];
                entity.comment.text += "\n" + comment[2];
              }
              if (comment[1] === "AnnotatorNotes") {
                entity.annotatorNotes = comment[2];
              }
              if (commentPriority(comment[1]) > commentPriority(entity.shadowClass)) {
                return entity.shadowClass = comment[1];
              }
            });
          }
        });
        $.each(sourceData.normalizations, function(normNo, norm) {
          var id, normType, refdb, refid, reftext, span, target;

          id = norm[0];
          normType = norm[1];
          target = norm[2];
          refdb = norm[3];
          refid = norm[4];
          reftext = norm[5];
          span = data.spans[target];
          if (!span) {
            dispatcher.post("messages", [[["Annotation " + target + ", referenced from normalization " + id + ", does not exist.", "error"]]]);
            return;
          }
          span.normalizations.push([refdb, refid, reftext]);
          return span.normalized = "Normalized";
        });
        sortedFragments = [];
        $.each(data.spans, function(spanNo, span) {
          return $.each(span.fragments, function(fragmentNo, fragment) {
            return sortedFragments.push(fragment);
          });
        });
        sortedFragments.sort(function(a, b) {
          var x, y;

          x = a.from;
          y = b.from;
          if (x === y) {
            x = a.to;
            y = b.to;
          }
          if (x < y) {
            return -1;
          } else {
            if (x > y) {
              return 1;
            } else {
              return 0;
            }
          }
        });
        currentFragmentId = 0;
        startFragmentId = 0;
        numFragments = sortedFragments.length;
        lastTo = 0;
        firstFrom = null;
        chunkNo = 0;
        space = void 0;
        chunk = null;
        $.each(sourceData.token_offsets, function() {
          var from, text, to;

          from = this[0];
          to = this[1];
          if (firstFrom === null) {
            firstFrom = from;
          }
          if (startFragmentId && to > sortedFragments[startFragmentId - 1].to) {
            while (startFragmentId < numFragments && to > sortedFragments[startFragmentId].from) {
              startFragmentId++;
            }
          }
          currentFragmentId = startFragmentId;
          while (currentFragmentId < numFragments && to >= sortedFragments[currentFragmentId].to) {
            currentFragmentId++;
          }
          if (currentFragmentId < numFragments && to > sortedFragments[currentFragmentId].from) {
            return;
          }
          space = data.text.substring(lastTo, firstFrom);
          text = data.text.substring(firstFrom, to);
          if (chunk) {
            chunk.nextSpace = space;
          }
          chunk = new Chunk(chunkNo++, text, firstFrom, to, space);
          data.chunks.push(chunk);
          lastTo = to;
          return firstFrom = null;
        });
        numChunks = chunkNo;
        chunkNo = 0;
        sentenceNo = 0;
        pastFirst = false;
        $.each(sourceData.sentence_offsets, function() {
          var from, numNL;

          from = this[0];
          if (chunkNo >= numChunks) {
            return false;
          }
          if (data.chunks[chunkNo].from > from) {
            return;
          }
          chunk = void 0;
          while (chunkNo < numChunks && (chunk = data.chunks[chunkNo]).from < from) {
            chunkNo++;
          }
          chunkNo++;
          if (pastFirst && from <= chunk.from) {
            numNL = chunk.space.split("\n").length - 1;
            if (!numNL) {
              numNL = 1;
            }
            sentenceNo += numNL;
            return chunk.sentence = sentenceNo;
          } else {
            return pastFirst = true;
          }
        });
        currentChunkId = 0;
        chunk = void 0;
        $.each(sortedFragments, function(fragmentId, fragment) {
          while (fragment.to > (chunk = data.chunks[currentChunkId]).to) {
            currentChunkId++;
          }
          chunk.fragments.push(fragment);
          fragment.text = chunk.text.substring(fragment.from - chunk.from, fragment.to - chunk.from);
          return fragment.chunk = chunk;
        });
        $.each(data.eventDescs, function(eventNo, eventDesc) {
          var dist, here, origin;

          dist = 0;
          origin = data.spans[eventDesc.id];
          if (!origin) {
            dispatcher.post("messages", [[["<strong>ERROR</strong><br/>Trigger for event \"" + eventDesc.id + "\" not found in " + data.document + "<br/>(please correct the source data)", "error", 5]]]);
            return;
          }
          here = origin.headFragment.from + origin.headFragment.to;
          return $.each(eventDesc.roles, function(roleNo, role) {
            var arc, arcId, target, there;

            target = data.spans[role.targetId];
            if (!target) {
              dispatcher.post("messages", [[["<strong>ERROR</strong><br/>\"" + role.targetId + "\" (referenced from \"" + eventDesc.id + "\") not found in " + data.document + "<br/>(please correct the source data)", "error", 5]]]);
              return;
            }
            there = target.headFragment.from + target.headFragment.to;
            dist = Math.abs(here - there);
            arc = new Arc(eventDesc, role, dist, eventNo);
            origin.totalDist += dist;
            origin.numArcs++;
            target.totalDist += dist;
            target.numArcs++;
            data.arcs.push(arc);
            target.incoming.push(arc);
            origin.outgoing.push(arc);
            arcId = origin.id + "--" + role.type + "--" + target.id;
            return data.arcById[arcId] = arc;
          });
        });
        markedText = [];
        setMarked("edited");
        setMarked("focus");
        setMarked("matchfocus");
        setMarked("match");
        $.each(data.spans, function(spanId, span) {
          var fragmentTexts, lastSpan;

          span.avgDist = (span.numArcs ? span.totalDist / span.numArcs : 0);
          lastSpan = span;
          fragmentTexts = [];
          $.each(span.fragments, function(fragmentNo, fragment) {
            return fragmentTexts.push(fragment.text);
          });
          return span.text = fragmentTexts.join("");
        });
        i = 0;
        while (i < 2) {
          $.each(data.chunks, function(chunkNo, chunk) {
            chunk.fragments.sort(fragmentComparator);
            return $.each(chunk.fragments, function(fragmentNo, fragment) {
              return fragment.indexNumber = fragmentNo;
            });
          });
          $.each(data.spans, function(spanNo, span) {
            return span.refedIndexSum = 0;
          });
          $.each(data.arcs, function(arcNo, arc) {
            return data.spans[arc.origin].refedIndexSum += data.spans[arc.target].headFragment.indexNumber;
          });
          i++;
        }
        $.each(data.chunks, function(chunkNo, chunk) {
          chunk.fragments.sort(fragmentComparator);
          return $.each(chunk.fragments, function(fragmentNo, fragment) {
            return fragment.drawOrder = fragmentNo;
          });
        });
        data.spanDrawOrderPermutation = Object.keys(data.spans);
        data.spanDrawOrderPermutation.sort(function(a, b) {
          var spanA, spanB, tmp;

          spanA = data.spans[a];
          spanB = data.spans[b];
          tmp = spanA.headFragment.drawOrder - spanB.headFragment.drawOrder;
          if (tmp) {
            return (tmp < 0 ? -1 : 1);
          }
          return 0;
        });
        sortedFragments.sort(midpointComparator);
        lastFragment = null;
        towerId = -1;
        $.each(sortedFragments, function(i, fragment) {
          if (!lastFragment || (lastFragment.from !== fragment.from || lastFragment.to !== fragment.to)) {
            towerId++;
          }
          fragment.towerId = towerId;
          return lastFragment = fragment;
        });
        $.each(data.spanDrawOrderPermutation, function(spanIdNo, spanId) {
          var span;

          span = data.spans[spanId];
          return $.each(span.fragments, function(fragmentNo, fragment) {
            if (!data.towers[fragment.towerId]) {
              data.towers[fragment.towerId] = [];
              fragment.drawCurly = true;
              fragment.span.drawCurly = true;
            }
            return data.towers[fragment.towerId].push(fragment);
          });
        });
        spanAnnTexts = {};
        $.each(data.chunks, function(chunkNo, chunk) {
          chunk.markedTextStart = [];
          chunk.markedTextEnd = [];
          return $.each(chunk.fragments, function(fragmentNo, fragment) {
            var labelIdx, maxLength, postfix, postfixArray, prefix, spanLabels, svgtext, text, warning;

            if (chunk.firstFragmentIndex === undefined) {
              chunk.firstFragmentIndex = fragment.towerId;
            }
            chunk.lastFragmentIndex = fragment.towerId;
            spanLabels = Util.getSpanLabels(spanTypes, fragment.span.type);
            fragment.labelText = Util.spanDisplayForm(spanTypes, fragment.span.type);
            if (Configuration.abbrevsOn && spanLabels) {
              labelIdx = 1;
              maxLength = (fragment.to - fragment.from) / 0.8;
              while (fragment.labelText.length > maxLength && spanLabels[labelIdx]) {
                fragment.labelText = spanLabels[labelIdx];
                labelIdx++;
              }
            }
            svgtext = svg.createText();
            postfixArray = [];
            prefix = "";
            postfix = "";
            warning = false;
            $.each(fragment.span.attributes, function(attrType, valType) {
              var attr, css, val;

              attr = eventAttributeTypes[attrType] || entityAttributeTypes[attrType];
              if (!attr) {
                warning = true;
                return;
              }
              val = attr.values[attr.bool || valType];
              if (!val) {
                warning = true;
                return;
              }
              if ($.isEmptyObject(val)) {
                warning = true;
                return;
              }
              if (val.glyph) {
                if (val.position === "left") {
                  prefix = val.glyph + prefix;
                  css = "glyph";
                  if (attr.css) {
                    css += " glyph_" + Util.escapeQuotes(attr.css);
                  }
                  return svgtext.span(val.glyph, {
                    "class": css
                  });
                } else {
                  postfixArray.push([attr, val]);
                  return postfix += val.glyph;
                }
              }
            });
            text = fragment.labelText;
            if (prefix !== "") {
              text = prefix + " " + text;
              svgtext.string(" ");
            }
            svgtext.string(fragment.labelText);
            if (postfixArray.length) {
              text += " " + postfix;
              svgtext.string(" ");
              $.each(postfixArray, function(elNo, el) {
                var css;

                css = "glyph";
                if (el[0].css) {
                  css += " glyph_" + Util.escapeQuotes(el[0].css);
                }
                return svgtext.span(el[1].glyph, {
                  "class": css
                });
              });
            }
            if (warning) {
              svgtext.span("#", {
                "class": "glyph attribute_warning"
              });
              text += " #";
            }
            fragment.glyphedLabelText = text;
            if (!spanAnnTexts[text]) {
              spanAnnTexts[text] = true;
              return data.spanAnnTexts[text] = svgtext;
            }
          });
        });
        numChunks = data.chunks.length;
        startChunk = 0;
        currentChunk = void 0;
        markedText.sort(function(a, b) {
          return Util.cmp(a[0], b[0]);
        });
        $.each(markedText, function(textNo, textPos) {
          var from, markedType, to;

          from = textPos[0];
          to = textPos[1];
          markedType = textPos[2];
          if (from < 0) {
            from = 0;
          }
          if (to < 0) {
            to = 0;
          }
          if (to >= data.text.length) {
            to = data.text.length - 1;
          }
          if (from > to) {
            from = to;
          }
          while (startChunk < numChunks) {
            chunk = data.chunks[startChunk];
            if (from <= chunk.to) {
              chunk.markedTextStart.push([textNo, true, from - chunk.from, null, markedType]);
              break;
            }
            startChunk++;
          }
          if (startChunk === numChunks) {
            dispatcher.post("messages", [[["Wrong text offset", "error"]]]);
            return;
          }
          currentChunk = startChunk;
          while (currentChunk < numChunks) {
            chunk = data.chunks[currentChunk];
            if (to <= chunk.to) {
              chunk.markedTextEnd.push([textNo, false, to - chunk.from]);
              break;
            }
            currentChunk++;
          }
          if (currentChunk === numChunks) {
            dispatcher.post("messages", [[["Wrong text offset", "error"]]]);
            chunk = data.chunks[data.chunks.length - 1];
            chunk.markedTextEnd.push([textNo, false, chunk.text.length]);
          }
        });
        return dispatcher.post("dataReady", [data]);
      };
      resetData = function() {
        setData(sourceData);
        return renderData();
      };
      translate = function(element, x, y) {
        $(element.group).attr("transform", "translate(" + x + ", " + y + ")");
        return element.translation = {
          x: x,
          y: y
        };
      };
      showMtime = function() {
        if (data.mtime) {
          return $("#document_mtime").text("Last modified: " + Util.formatTimeAgo(1000 * data.mtime)).css("display", "inline");
        } else {
          return $("#document_mtime").css("display", "none");
        }
      };
      addHeaderAndDefs = function() {
        var $blurFilter, commentName, defs;

        commentName = (coll + "/" + doc).replace("--", "-\\-");
        $svg.append("<!-- document: " + commentName + " -->");
        defs = svg.defs();
        $blurFilter = $("<filter id=\"Gaussian_Blur\"><feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"2\" /></filter>");
        svg.add(defs, $blurFilter);
        return defs;
      };
      getTextMeasurements = function(textsHash, options, callback) {
        var bbox, text, textMeasureGroup, widths;

        textMeasureGroup = svg.group(options);
        for (text in textsHash) {
          if (textsHash.hasOwnProperty(text)) {
            svg.text(textMeasureGroup, 0, 0, text);
          }
        }
        widths = {};
        $(textMeasureGroup).find("text").each(function(svgTextNo, svgText) {
          text = $(svgText).text();
          widths[text] = this.getComputedTextLength();
          if (callback) {
            return $.each(textsHash[text], function(text, object) {
              return callback(object, svgText);
            });
          }
        });
        bbox = textMeasureGroup.getBBox();
        svg.remove(textMeasureGroup);
        return new Measurements(widths, bbox.height, bbox.y);
      };
      getTextAndSpanTextMeasurements = function() {
        var chunkTexts, fragmentSizes, fragmentTexts, noSpans, textSizes;

        chunkTexts = {};
        $.each(data.chunks, function(chunkNo, chunk) {
          var chunkText;

          chunk.row = undefined;
          if (!(chunk.text in chunkTexts)) {
            chunkTexts[chunk.text] = [];
          }
          chunkText = chunkTexts[chunk.text];
          chunkText.push.apply(chunkText, chunk.fragments);
          chunkText.push.apply(chunkText, chunk.markedTextStart);
          return chunkText.push.apply(chunkText, chunk.markedTextEnd);
        });
        textSizes = getTextMeasurements(chunkTexts, undefined, function(fragment, text) {
          var endPos, firstChar, lastChar, startPos, textUpToFirstChar, textUpToFirstCharUnspaced, textUpToLastChar, textUpToLastCharUnspaced;

          if (fragment instanceof Fragment) {
            firstChar = fragment.from - fragment.chunk.from;
            if (firstChar < 0) {
              firstChar = 0;
              dispatcher.post("messages", [[["<strong>WARNING</strong>" + "<br/> " + "The fragment [" + fragment.from + ", " + fragment.to + "] (" + fragment.text + ") is not " + "contained in its designated chunk [" + fragment.chunk.from + ", " + fragment.chunk.to + "] most likely " + "due to the fragment starting or ending with a space, please " + "verify the sanity of your data since we are unable to " + "visualise this fragment correctly and will drop leading " + "space characters", "warning", 15]]]);
            }
            lastChar = fragment.to - fragment.chunk.from - 1;
            textUpToFirstChar = fragment.chunk.text.substring(0, firstChar);
            textUpToLastChar = fragment.chunk.text.substring(0, lastChar);
            textUpToFirstCharUnspaced = textUpToFirstChar.replace(/\s\s+/g, " ");
            textUpToLastCharUnspaced = textUpToLastChar.replace(/\s\s+/g, " ");
            firstChar -= textUpToFirstChar.length - textUpToFirstCharUnspaced.length;
            lastChar -= textUpToLastChar.length - textUpToLastCharUnspaced.length;
            startPos = text.getStartPositionOfChar(firstChar).x;
            endPos = (lastChar < 0 ? startPos : text.getEndPositionOfChar(lastChar).x);
            return fragment.curly = {
              from: startPos,
              to: endPos
            };
          } else {
            if (fragment[2] < 0) {
              fragment[2] = 0;
            }
            if (!fragment[2]) {
              return fragment[3] = text.getStartPositionOfChar(fragment[2]).x;
            } else {
              return fragment[3] = text.getEndPositionOfChar(fragment[2] - 1).x + 1;
            }
          }
        });
        fragmentTexts = {};
        noSpans = true;
        $.each(data.spans, function(spanNo, span) {
          return $.each(span.fragments, function(fragmentNo, fragment) {
            fragmentTexts[fragment.glyphedLabelText] = true;
            return noSpans = false;
          });
        });
        if (noSpans) {
          fragmentTexts.$ = true;
        }
        fragmentSizes = getTextMeasurements(fragmentTexts, {
          "class": "span"
        });
        return {
          texts: textSizes,
          fragments: fragmentSizes
        };
      };
      addArcTextMeasurements = function(sizes) {
        var arcSizes, arcTexts;

        arcTexts = {};
        $.each(data.arcs, function(arcNo, arc) {
          var labels;

          labels = Util.getArcLabels(spanTypes, data.spans[arc.origin].type, arc.type, relationTypesHash);
          if (!labels.length) {
            labels = [arc.type];
          }
          return $.each(labels, function(labelNo, label) {
            return arcTexts[label] = true;
          });
        });
        arcSizes = getTextMeasurements(arcTexts, {
          "class": "arcs"
        });
        return sizes.arcs = arcSizes;
      };
      adjustTowerAnnotationSizes = function() {
        return $.each(data.towers, function(towerNo, tower) {
          var maxWidth;

          maxWidth = 0;
          $.each(tower, function(fragmentNo, fragment) {
            var width;

            width = data.sizes.fragments.widths[fragment.glyphedLabelText];
            if (width > maxWidth) {
              return maxWidth = width;
            }
          });
          return $.each(tower, function(fragmentNo, fragment) {
            return fragment.width = maxWidth;
          });
        });
      };
      makeArrow = function(defs, spec) {
        var arrow, arrowId, color, height, parsedSpec, type, width;

        parsedSpec = spec.split(",");
        type = parsedSpec[0];
        if (type === "none") {
          return;
        }
        width = 5;
        height = 5;
        color = "black";
        if ($.isNumeric(parsedSpec[1]) && parsedSpec[2]) {
          if ($.isNumeric(parsedSpec[2]) && parsedSpec[3]) {
            width = parsedSpec[1];
            height = parsedSpec[2];
            color = parsedSpec[3] || "black";
          } else {
            width = height = parsedSpec[1];
            color = parsedSpec[2] || "black";
          }
        } else {
          width = height = 5;
          color = parsedSpec[1] || "black";
        }
        arrowId = "arrow_" + spec.replace(/#/g, "").replace(/,/g, "_");
        arrow = void 0;
        if (type === "triangle") {
          arrow = svg.marker(defs, arrowId, width, height / 2, width, height, "auto", {
            markerUnits: "strokeWidth",
            fill: color
          });
          svg.polyline(arrow, [[0, 0], [width, height / 2], [0, height], [width / 12, height / 2]]);
        }
        return arrowId;
      };
      drawing = false;
      redraw = false;
      renderDataReal = function(sourceData) {
        var arcCache, arcDragArc, arrow, arrowhead, arrows, backgroundGroup, canvasWidth, currentChunk, currentSent, currentX, defs, floors, fragmentHeights, glowGroup, heightsRowsAdded, heightsStart, i, inf, len, lrChunkComp, maxTextWidth, openTextHighlights, reservations, rlChunkComp, row, rowIndex, rows, sentNumGroup, sentenceNumber, sentenceText, sentenceToggle, sizes, text, textGroup, textMarkedRows, twoBarWidths, width, y;

        Util.profileEnd("before render");
        Util.profileStart("render");
        Util.profileStart("init");
        if (!sourceData && !data) {
          dispatcher.post("doneRendering", [coll, doc, args]);
          return;
        }
        $svgDiv.show();
        if ((sourceData && sourceData.collection && (sourceData.document !== doc || sourceData.collection !== coll)) || drawing) {
          redraw = true;
          dispatcher.post("doneRendering", [coll, doc, args]);
          return;
        }
        redraw = false;
        drawing = true;
        if (sourceData) {
          setData(sourceData);
        }
        showMtime();
        svg.clear(true);
        if (!data || data.length === 0) {
          return;
        }
        canvasWidth = that.forceWidth || $svgDiv.width();
        defs = addHeaderAndDefs();
        backgroundGroup = svg.group({
          "class": "background"
        });
        glowGroup = svg.group({
          "class": "glow"
        });
        highlightGroup = svg.group({
          "class": "highlight"
        });
        textGroup = svg.group({
          "class": "text"
        });
        Util.profileEnd("init");
        Util.profileStart("measures");
        sizes = getTextAndSpanTextMeasurements();
        data.sizes = sizes;
        adjustTowerAnnotationSizes();
        maxTextWidth = 0;
        for (text in sizes.texts.widths) {
          if (sizes.texts.widths.hasOwnProperty(text)) {
            width = sizes.texts.widths[text];
            if (width > maxTextWidth) {
              maxTextWidth = width;
            }
          }
        }
        Util.profileEnd("measures");
        Util.profileStart("chunks");
        currentX = Configuration.visual.margin.x + sentNumMargin + rowPadding;
        rows = [];
        fragmentHeights = [];
        sentenceToggle = 0;
        sentenceNumber = 0;
        row = new Row(svg);
        row.sentence = ++sentenceNumber;
        row.backgroundIndex = sentenceToggle;
        row.index = 0;
        rowIndex = 0;
        twoBarWidths = void 0;
        openTextHighlights = {};
        textMarkedRows = [];
        addArcTextMeasurements(sizes);
        floors = [];
        reservations = [];
        i = 0;
        while (i <= data.lastFragmentIndex) {
          reservation[i] = {};
          i++;
        }
        inf = 1.0 / 0.0;
        $.each(data.spanDrawOrderPermutation, function(spanIdNo, spanId) {
          var carpet, carpetNo, ceiling, ceilingNo, f1, f2, floor, floorNo, from, headroom, height, i1, i2, makeNewFloorIfNeeded, outside, reslen, span, thisCurlyHeight, to, x1, x2;

          span = data.spans[spanId];
          f1 = span.fragments[0];
          f2 = span.fragments[span.fragments.length - 1];
          x1 = (f1.curly.from + f1.curly.to - f1.width) / 2 - Configuration.visual.margin.x;
          i1 = f1.chunk.index;
          x2 = (f2.curly.from + f2.curly.to + f2.width) / 2 + Configuration.visual.margin.x;
          i2 = f2.chunk.index;
          carpet = 0;
          outside = true;
          thisCurlyHeight = (span.drawCurly ? Configuration.visual.curlyHeight : 0);
          height = sizes.fragments.height + thisCurlyHeight + Configuration.visual.boxSpacing + 2 * Configuration.visual.margin.y - 3;
          $.each(floors, function(floorNo, floor) {
            var floorAvailable, from, to;

            floorAvailable = true;
            i = i1;
            while (i <= i2) {
              if (!(reservations[i] && reservations[i][floor])) {
                continue;
              }
              from = (i === i1 ? x1 : -inf);
              to = (i === i2 ? x2 : inf);
              $.each(reservations[i][floor], function(resNo, res) {
                if (res[0] < to && from < res[1]) {
                  floorAvailable = false;
                  return false;
                }
              });
              i++;
            }
            if (floorAvailable) {
              if (carpet === null) {
                return carpet = floor;
              } else if (height + carpet <= floor) {
                outside = false;
                return false;
              }
            } else {
              return carpet = null;
            }
          });
          reslen = reservations.length;
          makeNewFloorIfNeeded = function(floor) {
            var floorNo, footroom, parquet;

            floorNo = $.inArray(floor, floors);
            if (floorNo === -1) {
              floors.push(floor);
              floors.sort(Util.cmp);
              floorNo = $.inArray(floor, floors);
              if (floorNo !== 0) {
                parquet = floors[floorNo - 1];
                i = 0;
                while (i <= reslen) {
                  if (reservations[i]) {
                    if (!reservations[i][parquet]) {
                      reservations[i][parquet] = [];
                    }
                    footroom = floor - parquet;
                    $.each(reservations[i][parquet], function(resNo, res) {
                      if (res[2] > footroom) {
                        if (!reservations[i][floor]) {
                          reservations[i][floor] = [];
                        }
                        return reservations[i][floor].push([res[0], res[1], res[2] - footroom]);
                      }
                    });
                  }
                  i++;
                }
              }
            }
            return floorNo;
          };
          ceiling = carpet + height;
          ceilingNo = makeNewFloorIfNeeded(ceiling);
          carpetNo = makeNewFloorIfNeeded(carpet);
          floor = void 0;
          floorNo = void 0;
          floorNo = carpetNo;
          while ((floor = floors[floorNo]) !== undefined && floor < ceiling) {
            headroom = ceiling - floor;
            i = i1;
            while (i <= i2) {
              from = (i === i1 ? x1 : 0);
              to = (i === i2 ? x2 : inf);
              if (!reservations[i]) {
                reservations[i] = {};
              }
              if (!reservations[i][floor]) {
                reservations[i][floor] = [];
              }
              reservations[i][floor].push([from, to, headroom]);
              i++;
            }
            floorNo++;
          }
          return span.floor = carpet + thisCurlyHeight;
        });
        $.each(data.chunks, function(chunkNo, chunk) {
          var adjustedCurTextWidth, boxWidth, boxX, chunkFrom, chunkHeight, chunkIndex, chunkTo, firstChunkInRow, hasAnnotations, hasInternalArcs, hasLeftArcs, hasRightArcs, lastRow, lastX, minArcDist, movedChunk, rightBorderForArcs, spaceLen, spaceWidth, spacing, spacingChunkId, spacingRowBreak, textWidth, y;

          reservations = new Array();
          chunk.group = svg.group(row.group);
          chunk.highlightGroup = svg.group(chunk.group);
          y = 0;
          minArcDist = void 0;
          hasLeftArcs = void 0;
          hasRightArcs = void 0;
          hasInternalArcs = void 0;
          hasAnnotations = void 0;
          chunkFrom = Infinity;
          chunkTo = 0;
          chunkHeight = 0;
          spacing = 0;
          spacingChunkId = null;
          spacingRowBreak = 0;
          $.each(chunk.fragments, function(fragmentNo, fragment) {
            var bgColor, bh, borderColor, bottom, bw, bx, by_, curlyColor, fgColor, fragmentHeight, hh, markedRect, rectClass, shadowRect, spacedTowerId, span, spanDesc, ww, x, xx, yy;

            span = fragment.span;
            spanDesc = spanTypes[span.type];
            bgColor = (spanDesc && spanDesc.bgColor) || (spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.bgColor) || "#ffffff";
            fgColor = (spanDesc && spanDesc.fgColor) || (spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.fgColor) || "#000000";
            borderColor = (spanDesc && spanDesc.borderColor) || (spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.borderColor) || "#000000";
            if (borderColor === "darken") {
              borderColor = Util.adjustColorLightness(bgColor, -0.6);
            }
            fragment.group = svg.group(chunk.group, {
              "class": "span"
            });
            fragmentHeight = 0;
            if (!y) {
              y = -sizes.texts.height;
            }
            x = (fragment.curly.from + fragment.curly.to) / 2;
            yy = y + sizes.fragments.y;
            hh = sizes.fragments.height;
            ww = fragment.width;
            xx = x - ww / 2;
            yy += boxTextMargin.y;
            hh -= 2 * boxTextMargin.y;
            xx += boxTextMargin.x;
            ww -= 2 * boxTextMargin.x;
            rectClass = "span_" + (span.cue || span.type) + " span_default";
            if (span.comment && span.comment.type) {
              rectClass += " " + span.comment.type;
            }
            bx = xx - Configuration.visual.margin.x - boxTextMargin.x;
            by_ = yy - Configuration.visual.margin.y;
            bw = ww + 2 * Configuration.visual.margin.x;
            bh = hh + 2 * Configuration.visual.margin.y;
            if (roundCoordinates) {
              x = (x | 0) + 0.5;
              bx = (bx | 0) + 0.5;
            }
            shadowRect = void 0;
            markedRect = void 0;
            if (span.marked) {
              markedRect = svg.rect(chunk.highlightGroup, bx - markedSpanSize, by_ - markedSpanSize, bw + 2 * markedSpanSize, bh + 2 * markedSpanSize, {
                "class": "shadow_EditHighlight",
                rx: markedSpanSize,
                ry: markedSpanSize
              });
              svg.other(markedRect, "animate", {
                "data-type": span.marked,
                attributeName: "fill",
                values: (span.marked === "match" ? highlightMatchSequence : highlightSpanSequence),
                dur: highlightDuration,
                repeatCount: "indefinite",
                begin: "indefinite"
              });
              chunkFrom = Math.min(bx - markedSpanSize, chunkFrom);
              chunkTo = Math.max(bx + bw + markedSpanSize, chunkTo);
              fragmentHeight = Math.max(bh + 2 * markedSpanSize, fragmentHeight);
            }
            if (span.shadowClass && span.shadowClass.match("True_positive|False_positive|False_negative|AnnotationError|AnnotationWarning|AnnotatorNotes|Normalized|AnnotationIncomplete|AnnotationUnconfirmed|rectEditHighlight|EditHighlight_arc|MissingAnnotation|ChangedAnnotation ")) {
              shadowRect = svg.rect(fragment.group, bx - rectShadowSize, by_ - rectShadowSize, bw + 2 * rectShadowSize, bh + 2 * rectShadowSize, {
                "class": "shadow_" + span.shadowClass,
                filter: "url(#Gaussian_Blur)",
                rx: rectShadowRounding,
                ry: rectShadowRounding
              });
              chunkFrom = Math.min(bx - rectShadowSize, chunkFrom);
              chunkTo = Math.max(bx + bw + rectShadowSize, chunkTo);
              fragmentHeight = Math.max(bh + 2 * rectShadowSize, fragmentHeight);
            }
            fragment.rect = svg.rect(fragment.group, bx, by_, bw, bh, {
              "class": rectClass,
              fill: bgColor,
              stroke: borderColor,
              rx: Configuration.visual.margin.x,
              ry: Configuration.visual.margin.y,
              "data-span-id": span.id,
              "data-fragment-id": span.segmentedOffsetsMap[fragment.id],
              strokeDashArray: span.attributeMerge.dashArray
            });
            if (span.normalized) {
              $(fragment.rect).addClass(span.normalized);
            }
            fragment.right = bx + bw;
            if (!(span.shadowClass || span.marked)) {
              chunkFrom = Math.min(bx, chunkFrom);
              chunkTo = Math.max(bx + bw, chunkTo);
              fragmentHeight = Math.max(bh, fragmentHeight);
            }
            fragment.rectBox = {
              x: bx,
              y: by_ - span.floor,
              width: bw,
              height: bh
            };
            fragment.height = span.floor + hh + 3 * Configuration.visual.margin.y + Configuration.visual.curlyHeight + Configuration.visual.arcSpacing;
            spacedTowerId = fragment.towerId * 2;
            if (!fragmentHeights[spacedTowerId] || fragmentHeights[spacedTowerId] < fragment.height) {
              fragmentHeights[spacedTowerId] = fragment.height;
            }
            $(fragment.rect).attr("y", yy - Configuration.visual.margin.y - span.floor);
            if (shadowRect) {
              $(shadowRect).attr("y", yy - rectShadowSize - Configuration.visual.margin.y - span.floor);
            }
            if (markedRect) {
              $(markedRect).attr("y", yy - markedSpanSize - Configuration.visual.margin.y - span.floor);
            }
            if (span.attributeMerge.box === "crossed") {
              svg.path(fragment.group, svg.createPath().move(xx, yy - Configuration.visual.margin.y - span.floor).line(xx + fragment.width, yy + hh + Configuration.visual.margin.y - span.floor), {
                "class": "boxcross"
              });
              svg.path(fragment.group, svg.createPath().move(xx + fragment.width, yy - Configuration.visual.margin.y - span.floor).line(xx, yy + hh + Configuration.visual.margin.y - span.floor), {
                "class": "boxcross"
              });
            }
            svg.text(fragment.group, x, y - span.floor, data.spanAnnTexts[fragment.glyphedLabelText], {
              fill: fgColor
            });
            if (fragment.drawCurly) {
              curlyColor = "grey";
              if (coloredCurlies) {
                spanDesc = spanTypes[span.type];
                bgColor = (spanDesc && spanDesc.bgColor) || (spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.fgColor) || "#000000";
                curlyColor = Util.adjustColorLightness(bgColor, -0.6);
              }
              bottom = yy + hh + Configuration.visual.margin.y - span.floor + 1;
              svg.path(fragment.group, svg.createPath().move(fragment.curly.from, bottom + Configuration.visual.curlyHeight).curveC(fragment.curly.from, bottom, x, bottom + Configuration.visual.curlyHeight, x, bottom).curveC(x, bottom + Configuration.visual.curlyHeight, fragment.curly.to, bottom, fragment.curly.to, bottom + Configuration.visual.curlyHeight), {
                "class": "curly",
                stroke: curlyColor
              });
              chunkFrom = Math.min(fragment.curly.from, chunkFrom);
              chunkTo = Math.max(fragment.curly.to, chunkTo);
              fragmentHeight = Math.max(Configuration.visual.curlyHeight, fragmentHeight);
            }
            if (fragment === span.headFragment) {
              $.each(span.incoming, function(arcId, arc) {
                var arcSpacing, border, gap, labelNo, labels, leftSpan, origin, smallestLabelWidth;

                leftSpan = data.spans[arc.origin];
                origin = leftSpan.headFragment.chunk;
                border = void 0;
                if (chunk.index === origin.index) {
                  hasInternalArcs = true;
                }
                if (origin.row) {
                  labels = Util.getArcLabels(spanTypes, leftSpan.type, arc.type, relationTypesHash);
                  if (!labels.length) {
                    labels = [arc.type];
                  }
                  if (origin.row.index === rowIndex) {
                    border = origin.translation.x + leftSpan.fragments[leftSpan.fragments.length - 1].right;
                  } else {
                    border = Configuration.visual.margin.x + sentNumMargin + rowPadding;
                  }
                  labelNo = (Configuration.abbrevsOn ? labels.length - 1 : 0);
                  smallestLabelWidth = sizes.arcs.widths[labels[labelNo]] + 2 * minArcSlant;
                  gap = currentX + bx - border;
                  arcSpacing = smallestLabelWidth - gap;
                  if (!hasLeftArcs || spacing < arcSpacing) {
                    spacing = arcSpacing;
                    spacingChunkId = origin.index + 1;
                  }
                  arcSpacing = smallestLabelWidth - bx;
                  if (!hasLeftArcs || spacingRowBreak < arcSpacing) {
                    spacingRowBreak = arcSpacing;
                  }
                  return hasLeftArcs = true;
                } else {
                  return hasRightArcs = true;
                }
              });
              $.each(span.outgoing, function(arcId, arc) {
                var arcSpacing, border, gap, labelNo, labels, leftSpan, smallestLabelWidth, target;

                leftSpan = data.spans[arc.target];
                target = leftSpan.headFragment.chunk;
                border = void 0;
                if (target.row) {
                  labels = Util.getArcLabels(spanTypes, span.type, arc.type, relationTypesHash);
                  if (!labels.length) {
                    labels = [arc.type];
                  }
                  if (target.row.index === rowIndex) {
                    border = target.translation.x + leftSpan.fragments[leftSpan.fragments.length - 1].right;
                  } else {
                    border = Configuration.visual.margin.x + sentNumMargin + rowPadding;
                  }
                  labelNo = (Configuration.abbrevsOn ? labels.length - 1 : 0);
                  smallestLabelWidth = sizes.arcs.widths[labels[labelNo]] + 2 * minArcSlant;
                  gap = currentX + bx - border;
                  arcSpacing = smallestLabelWidth - gap;
                  if (!hasLeftArcs || spacing < arcSpacing) {
                    spacing = arcSpacing;
                    spacingChunkId = target.index + 1;
                  }
                  arcSpacing = smallestLabelWidth - bx;
                  if (!hasLeftArcs || spacingRowBreak < arcSpacing) {
                    spacingRowBreak = arcSpacing;
                  }
                  return hasLeftArcs = true;
                } else {
                  return hasRightArcs = true;
                }
              });
            }
            fragmentHeight += span.floor || Configuration.visual.curlyHeight;
            if (fragmentHeight > chunkHeight) {
              chunkHeight = fragmentHeight;
            }
            return hasAnnotations = true;
          });
          chunk.right = chunkTo;
          textWidth = sizes.texts.widths[chunk.text];
          chunkHeight += sizes.texts.height;
          boxX = -Math.min(chunkFrom, 0);
          boxWidth = Math.max(textWidth, chunkTo) - Math.min(0, chunkFrom);
          if (spacing > 0) {
            currentX += spacing;
          }
          rightBorderForArcs = (hasRightArcs ? arcHorizontalSpacing : (hasInternalArcs ? arcSlant : 0));
          lastX = currentX;
          lastRow = row;
          if (chunk.sentence) {
            while (sentenceNumber < chunk.sentence) {
              sentenceNumber++;
              row.arcs = svg.group(row.group, {
                "class": "arcs"
              });
              rows.push(row);
              row = new Row(svg);
              sentenceToggle = 1 - sentenceToggle;
              row.backgroundIndex = sentenceToggle;
              row.index = ++rowIndex;
            }
            sentenceToggle = 1 - sentenceToggle;
          }
          if (chunk.sentence || currentX + boxWidth + rightBorderForArcs >= canvasWidth - 2 * Configuration.visual.margin.x) {
            row.arcs = svg.group(row.group, {
              "class": "arcs"
            });
            currentX = Configuration.visual.margin.x + sentNumMargin + rowPadding + (hasLeftArcs ? arcHorizontalSpacing : (hasInternalArcs ? arcSlant : 0));
            if (hasLeftArcs) {
              adjustedCurTextWidth = sizes.texts.widths[chunk.text] + arcHorizontalSpacing;
              if (adjustedCurTextWidth > maxTextWidth) {
                maxTextWidth = adjustedCurTextWidth;
              }
            }
            if (spacingRowBreak > 0) {
              currentX += spacingRowBreak;
              spacing = 0;
            }
            rows.push(row);
            svg.remove(chunk.group);
            row = new Row(svg);
            row.backgroundIndex = sentenceToggle;
            row.index = ++rowIndex;
            svg.add(row.group, chunk.group);
            chunk.group = row.group.lastElementChild;
            $(chunk.group).children("g[class='span']").each(function(index, element) {
              return chunk.fragments[index].group = element;
            });
            $(chunk.group).find("rect[data-span-id]").each(function(index, element) {
              return chunk.fragments[index].rect = element;
            });
          }
          if (row.index !== lastRow.index) {
            $.each(openTextHighlights, function(textId, textDesc) {
              var newDesc;

              if (textDesc[3] !== lastX) {
                newDesc = [lastRow, textDesc[3], lastX + boxX, textDesc[4]];
                textMarkedRows.push(newDesc);
              }
              return textDesc[3] = currentX;
            });
          }
          $.each(chunk.markedTextStart, function(textNo, textDesc) {
            textDesc[3] += currentX + boxX;
            return openTextHighlights[textDesc[0]] = textDesc;
          });
          $.each(chunk.markedTextEnd, function(textNo, textDesc) {
            var markedRow, startDesc;

            textDesc[3] += currentX + boxX;
            startDesc = openTextHighlights[textDesc[0]];
            delete openTextHighlights[textDesc[0]];
            markedRow = [row, startDesc[3], textDesc[3], startDesc[4]];
            return textMarkedRows.push(markedRow);
          });
          if (hasAnnotations) {
            row.hasAnnotations = true;
          }
          if (chunk.sentence) {
            row.sentence = ++sentenceNumber;
          }
          if (spacing > 0) {
            spacing /= 2;
            firstChunkInRow = row.chunks[row.chunks.length - 1];
            if (spacingChunkId < firstChunkInRow.index) {
              spacingChunkId = firstChunkInRow.index + 1;
            }
            chunkIndex = spacingChunkId;
            while (chunkIndex < chunk.index) {
              movedChunk = data.chunks[chunkIndex];
              translate(movedChunk, movedChunk.translation.x + spacing, 0);
              movedChunk.textX += spacing;
              chunkIndex++;
            }
          }
          row.chunks.push(chunk);
          chunk.row = row;
          translate(chunk, currentX + boxX, 0);
          chunk.textX = currentX + boxX;
          spaceWidth = 0;
          spaceLen = chunk.nextSpace && chunk.nextSpace.length || 0;
          i = 0;
          while (i < spaceLen) {
            spaceWidth += spaceWidths[chunk.nextSpace[i]] || 0;
            i++;
          }
          return currentX += spaceWidth + boxWidth;
        });
        row.arcs = svg.group(row.group, {
          "class": "arcs"
        });
        rows.push(row);
        Util.profileEnd("chunks");
        Util.profileStart("arcsPrep");
        arrows = {};
        arrow = makeArrow(defs, "none");
        if (arrow) {
          arrows["none"] = arrow;
        }
        len = fragmentHeights.length;
        i = 0;
        while (i < len) {
          if (!fragmentHeights[i] || fragmentHeights[i] < Configuration.visual.arcStartHeight) {
            fragmentHeights[i] = Configuration.visual.arcStartHeight;
          }
          i++;
        }
        $.each(data.arcs, function(arcNo, arc) {
          var from, fromFragment, tmp, to, toFragment, _results;

          arc.jumpHeight = 0;
          fromFragment = data.spans[arc.origin].headFragment;
          toFragment = data.spans[arc.target].headFragment;
          if (fromFragment.towerId > toFragment.towerId) {
            tmp = fromFragment;
            fromFragment = toFragment;
            toFragment = tmp;
          }
          from = void 0;
          to = void 0;
          if (fromFragment.chunk.index === toFragment.chunk.index) {
            from = fromFragment.towerId;
            to = toFragment.towerId;
          } else {
            from = fromFragment.towerId + 1;
            to = toFragment.towerId - 1;
          }
          i = from;
          _results = [];
          while (i <= to) {
            if (arc.jumpHeight < fragmentHeights[i * 2]) {
              arc.jumpHeight = fragmentHeights[i * 2];
            }
            _results.push(i++);
          }
          return _results;
        });
        data.arcs.sort(function(a, b) {
          var tmp;

          tmp = a.jumpHeight - b.jumpHeight;
          if (tmp) {
            return (tmp < 0 ? -1 : 1);
          }
          tmp = a.dist - b.dist;
          if (tmp) {
            return (tmp < 0 ? -1 : 1);
          }
          tmp = data.spans[a.origin].headFragment.height + data.spans[a.target].headFragment.height - data.spans[b.origin].headFragment.height - data.spans[b.target].headFragment.height;
          if (tmp) {
            return (tmp < 0 ? -1 : 1);
          }
          tmp = data.spans[a.origin].headFragment.height - data.spans[b.origin].headFragment.height;
          if (tmp) {
            return (tmp < 0 ? -1 : 1);
          }
          return 0;
        });
        heightsStart = 0;
        heightsRowsAdded = 0;
        $.each(rows, function(rowId, row) {
          var seenFragment;

          seenFragment = false;
          row.heightsStart = row.heightsEnd = heightsStart;
          $.each(row.chunks, function(chunkId, chunk) {
            var heightsIndex;

            if (chunk.lastFragmentIndex !== undefined) {
              seenFragment = true;
              heightsIndex = chunk.lastFragmentIndex * 2 + heightsRowsAdded;
              if (row.heightsEnd < heightsIndex) {
                row.heightsEnd = heightsIndex;
              }
              heightsIndex = chunk.firstFragmentIndex * 2 + heightsRowsAdded;
              if (row.heightsStart > heightsIndex) {
                return row.heightsStart = heightsIndex;
              }
            }
          });
          fragmentHeights.splice(row.heightsStart, 0, Configuration.visual.arcStartHeight);
          heightsRowsAdded++;
          row.heightsAdjust = heightsRowsAdded;
          if (seenFragment) {
            row.heightsEnd += 2;
          }
          return heightsStart = row.heightsEnd + 1;
        });
        arrowhead = svg.marker(defs, "drag_arrow", 5, 2.5, 5, 5, "auto", {
          markerUnits: "strokeWidth",
          "class": "drag_fill"
        });
        svg.polyline(arrowhead, [[0, 0], [5, 2.5], [0, 5], [0.2, 2.5]]);
        arcDragArc = svg.path(svg.createPath(), {
          markerEnd: "url(#drag_arrow)",
          "class": "drag_stroke",
          fill: "none",
          visibility: "hidden"
        });
        dispatcher.post("arcDragArcDrawn", [arcDragArc]);
        Util.profileEnd("arcsPrep");
        Util.profileStart("arcs");
        arcCache = {};
        $.each(data.arcs, function(arcNo, arc) {
          var adjustHeight, arcCacheKey, arcDesc, arcGroup, arcLabels, arrowAtLabelAdjust, arrowDecl, arrowEnd, arrowHead, arrowName, arrowStart, arrowType, baseline_shift, chunkReverse, color, controlx, cornerx, dashArray, endy, from, fromIndex2, fromIndex2R, height, labelArrowDecl, labelArrowHead, labelArrowName, labelArrowSplit, labelArrowType, labelIdx, labelText, left, leftBox, leftRow, leftSlantBound, leftToRight, line, markedRect, maxLength, myArrowHead, myLabelArrowHead, noNumArcType, noNumLabelText, options, originSpan, originType, path, right, rightBox, rightRow, rightSlantBound, rowHeight, shadowGroup, spanDesc, splitArcType, splitLabelText, subscriptSettings, svgText, symmetric, targetSpan, textBox, textEnd, textStart, tmp, to, toIndex2, toIndex2R, ufoCatcher, ufoCatcherMod, _results;

          noNumArcType = void 0;
          splitArcType = void 0;
          if (arc.type) {
            splitArcType = arc.type.match(/^(.*?)(\d*)$/);
            noNumArcType = splitArcType[1];
          }
          originSpan = data.spans[arc.origin];
          targetSpan = data.spans[arc.target];
          leftToRight = originSpan.headFragment.towerId < targetSpan.headFragment.towerId;
          left = void 0;
          right = void 0;
          if (leftToRight) {
            left = originSpan.headFragment;
            right = targetSpan.headFragment;
          } else {
            left = targetSpan.headFragment;
            right = originSpan.headFragment;
          }
          arcDesc = relationTypesHash[arc.type] || relationTypesHash[noNumArcType];
          spanDesc = spanTypes[originSpan.type];
          if (!arcDesc && spanDesc && spanDesc.arcs) {
            $.each(spanDesc.arcs, function(arcDescNo, arcDescIter) {
              if (arcDescIter.type === arc.type) {
                return arcDesc = arcDescIter;
              }
            });
          }
          if (!arcDesc && noNumArcType && noNumArcType !== arc.type && spanDesc && spanDesc.arcs) {
            $.each(spanDesc.arcs, function(arcDescNo, arcDescIter) {
              if (arcDescIter.type === noNumArcType) {
                return arcDesc = arcDescIter;
              }
            });
          }
          if (!arcDesc) {
            arcDesc = {};
          }
          color = (arcDesc && arcDesc.color) || (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.color) || "#000000";
          symmetric = arcDesc && arcDesc.properties && arcDesc.properties.symmetric;
          dashArray = arcDesc && arcDesc.dashArray;
          arrowHead = ((arcDesc && arcDesc.arrowHead) || (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.arrowHead) || "triangle,5") + "," + color;
          labelArrowHead = ((arcDesc && arcDesc.labelArrow) || (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.labelArrow) || "triangle,5") + "," + color;
          leftBox = rowBBox(left);
          rightBox = rowBBox(right);
          leftRow = left.chunk.row.index;
          rightRow = right.chunk.row.index;
          if (!arrows[arrowHead]) {
            arrow = makeArrow(defs, arrowHead);
            if (arrow) {
              arrows[arrowHead] = arrow;
            }
          }
          if (!arrows[labelArrowHead]) {
            arrow = makeArrow(defs, labelArrowHead);
            if (arrow) {
              arrows[labelArrowHead] = arrow;
            }
          }
          height = void 0;
          fromIndex2 = void 0;
          toIndex2 = void 0;
          if (left.chunk.index === right.chunk.index) {
            fromIndex2 = left.towerId * 2 + left.chunk.row.heightsAdjust;
            toIndex2 = right.towerId * 2 + right.chunk.row.heightsAdjust;
          } else {
            fromIndex2 = left.towerId * 2 + 1 + left.chunk.row.heightsAdjust;
            toIndex2 = right.towerId * 2 - 1 + right.chunk.row.heightsAdjust;
          }
          if (!collapseArcSpace) {
            height = findArcHeight(fromIndex2, toIndex2, fragmentHeights);
            adjustFragmentHeights(fromIndex2, toIndex2, fragmentHeights, height);
            height += 0.5;
          }
          leftSlantBound = void 0;
          rightSlantBound = void 0;
          chunkReverse = false;
          ufoCatcher = originSpan.headFragment.chunk.index === targetSpan.headFragment.chunk.index;
          if (ufoCatcher) {
            chunkReverse = leftBox.x + leftBox.width / 2 < rightBox.x + rightBox.width / 2;
          }
          ufoCatcherMod = (ufoCatcher ? (chunkReverse ? -0.5 : 0.5) : 1);
          rowIndex = leftRow;
          _results = [];
          while (rowIndex <= rightRow) {
            row = rows[rowIndex];
            if (row.chunks.length) {
              row.hasAnnotations = true;
              if (collapseArcSpace) {
                fromIndex2R = (rowIndex === leftRow ? fromIndex2 : row.heightsStart);
                toIndex2R = (rowIndex === rightRow ? toIndex2 : row.heightsEnd);
                height = findArcHeight(fromIndex2R, toIndex2R, fragmentHeights);
              }
              arcGroup = svg.group(row.arcs, {
                "data-from": arc.origin,
                "data-to": arc.target
              });
              from = void 0;
              to = void 0;
              if (rowIndex === leftRow) {
                from = leftBox.x + (chunkReverse ? 0 : leftBox.width);
              } else {
                from = sentNumMargin;
              }
              if (rowIndex === rightRow) {
                to = rightBox.x + (chunkReverse ? rightBox.width : 0);
              } else {
                to = canvasWidth - 2 * Configuration.visual.margin.y;
              }
              adjustHeight = true;
              if (collapseArcs) {
                arcCacheKey = arc.type + " " + rowIndex + " " + from + " " + to;
                if (rowIndex === leftRow) {
                  arcCacheKey = left.span.id + " " + arcCacheKey;
                }
                if (rowIndex === rightRow) {
                  arcCacheKey += " " + right.span.id;
                }
                rowHeight = arcCache[arcCacheKey];
                if (rowHeight !== undefined) {
                  height = rowHeight;
                  adjustHeight = false;
                } else {
                  arcCache[arcCacheKey] = height;
                }
              }
              if (collapseArcSpace && adjustHeight) {
                adjustFragmentHeights(fromIndex2R, toIndex2R, fragmentHeights, height);
                height += 0.5;
              }
              originType = data.spans[arc.origin].type;
              arcLabels = Util.getArcLabels(spanTypes, originType, arc.type, relationTypesHash);
              labelText = Util.arcDisplayForm(spanTypes, originType, arc.type, relationTypesHash);
              if (Configuration.abbrevsOn && arcLabels) {
                labelIdx = 1;
                maxLength = (to - from) - arcSlant;
                while (sizes.arcs.widths[labelText] > maxLength && arcLabels[labelIdx]) {
                  labelText = arcLabels[labelIdx];
                  labelIdx++;
                }
              }
              shadowGroup = void 0;
              if (arc.shadowClass || arc.marked) {
                shadowGroup = svg.group(arcGroup);
              }
              options = {
                fill: color,
                "data-arc-role": arc.type,
                "data-arc-origin": arc.origin,
                "data-arc-target": arc.target,
                "data-arc-ed": arc.eventDescId
              };
              svgText = void 0;
              if (!splitArcType[2]) {
                svgText = labelText;
              } else {
                splitLabelText = labelText.match(/^(.*?)(\d*)$/);
                noNumLabelText = splitLabelText[1];
                svgText = svg.createText();
                svgText.span(noNumLabelText, options);
                subscriptSettings = {
                  dy: "0.3em",
                  "font-size": "80%"
                };
                $.extend(subscriptSettings, options);
                svgText.span(splitArcType[2], subscriptSettings);
              }
              baseline_shift = sizes.arcs.height / 4;
              text = svg.text(arcGroup, (from + to) / 2, -height + baseline_shift, svgText, options);
              width = sizes.arcs.widths[labelText];
              textBox = {
                x: (from + to - width) / 2,
                width: width,
                y: -height - sizes.arcs.height / 2,
                height: sizes.arcs.height
              };
              if (arc.marked) {
                markedRect = svg.rect(shadowGroup, textBox.x - markedArcSize, textBox.y - markedArcSize, textBox.width + 2 * markedArcSize, textBox.height + 2 * markedArcSize, {
                  "class": "shadow_EditHighlight",
                  rx: markedArcSize,
                  ry: markedArcSize
                });
                svg.other(markedRect, "animate", {
                  "data-type": arc.marked,
                  attributeName: "fill",
                  values: (arc.marked === "match" ? highlightMatchSequence : highlightArcSequence),
                  dur: highlightDuration,
                  repeatCount: "indefinite",
                  begin: "indefinite"
                });
              }
              if (arc.shadowClass) {
                svg.rect(shadowGroup, textBox.x - arcLabelShadowSize, textBox.y - arcLabelShadowSize, textBox.width + 2 * arcLabelShadowSize, textBox.height + 2 * arcLabelShadowSize, {
                  "class": "shadow_" + arc.shadowClass,
                  filter: "url(#Gaussian_Blur)",
                  rx: arcLabelShadowRounding,
                  ry: arcLabelShadowRounding
                });
              }
              textStart = textBox.x;
              textEnd = textBox.x + textBox.width;
              textStart -= Configuration.visual.arcTextMargin;
              textEnd += Configuration.visual.arcTextMargin;
              if (from > to) {
                tmp = textStart;
                textStart = textEnd;
                textEnd = tmp;
              }
              path = void 0;
              if (roundCoordinates) {
                height = (height | 0) + 0.5;
              }
              if (height > row.maxArcHeight) {
                row.maxArcHeight = height;
              }
              myArrowHead = (arcDesc && arcDesc.arrowHead) || (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.arrowHead);
              arrowName = (symmetric ? myArrowHead || "none" : (leftToRight ? "none" : myArrowHead || "triangle,5")) + "," + color;
              arrowType = arrows[arrowName];
              arrowDecl = arrowType && ("url(#" + arrowType + ")");
              arrowAtLabelAdjust = 0;
              labelArrowDecl = null;
              myLabelArrowHead = (arcDesc && arcDesc.labelArrow) || (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.labelArrow);
              if (myLabelArrowHead) {
                labelArrowName = (leftToRight ? symmetric && myLabelArrowHead || "none" : myLabelArrowHead || "triangle,5") + "," + color;
                labelArrowSplit = labelArrowName.split(",");
                arrowAtLabelAdjust = labelArrowSplit[0] !== "none" && parseInt(labelArrowSplit[1], 10) || 0;
                labelArrowType = arrows[labelArrowName];
                labelArrowDecl = labelArrowType && ("url(#" + labelArrowType + ")");
                if (ufoCatcher) {
                  arrowAtLabelAdjust = -arrowAtLabelAdjust;
                }
              }
              arrowStart = textStart - arrowAtLabelAdjust;
              path = svg.createPath().move(arrowStart, -height);
              if (rowIndex === leftRow) {
                cornerx = from + ufoCatcherMod * arcSlant;
                if (!ufoCatcher && cornerx > arrowStart - 1) {
                  cornerx = arrowStart - 1;
                }
                if (smoothArcCurves) {
                  controlx = (ufoCatcher ? cornerx + 2 * ufoCatcherMod * reverseArcControlx : smoothArcSteepness * from + (1 - smoothArcSteepness) * cornerx);
                  endy = leftBox.y + (leftToRight || arc.equiv ? leftBox.height / 2 : Configuration.visual.margin.y);
                  if (Math.abs(-height - endy) < 2 && Math.abs(cornerx - from) < 5) {
                    endy = -height;
                  }
                  line = path.line(cornerx, -height).curveQ(controlx, -height, from, endy);
                } else {
                  path.line(cornerx, -height).line(from, leftBox.y + (leftToRight || arc.equiv ? leftBox.height / 2 : Configuration.visual.margin.y));
                }
              } else {
                path.line(from, -height);
              }
              svg.path(arcGroup, path, {
                markerEnd: arrowDecl,
                markerStart: labelArrowDecl,
                style: "stroke: " + color,
                strokeDashArray: dashArray
              });
              if (arc.marked) {
                svg.path(shadowGroup, path, {
                  "class": "shadow_EditHighlight_arc",
                  strokeWidth: markedArcStroke,
                  strokeDashArray: dashArray
                });
                svg.other(markedRect, "animate", {
                  "data-type": arc.marked,
                  attributeName: "fill",
                  values: (arc.marked === "match" ? highlightMatchSequence : highlightArcSequence),
                  dur: highlightDuration,
                  repeatCount: "indefinite",
                  begin: "indefinite"
                });
              }
              if (arc.shadowClass) {
                svg.path(shadowGroup, path, {
                  "class": "shadow_" + arc.shadowClass,
                  strokeWidth: shadowStroke,
                  strokeDashArray: dashArray
                });
              }
              if (!symmetric) {
                myArrowHead = (arcDesc && arcDesc.arrowHead) || (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.arrowHead);
                arrowName = (leftToRight ? myArrowHead || "triangle,5" : "none") + "," + color;
              }
              arrowType = arrows[arrowName];
              arrowDecl = arrowType && ("url(#" + arrowType + ")");
              arrowAtLabelAdjust = 0;
              labelArrowDecl = null;
              myLabelArrowHead = (arcDesc && arcDesc.labelArrow) || (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.labelArrow);
              if (myLabelArrowHead) {
                labelArrowName = (leftToRight ? myLabelArrowHead || "triangle,5" : symmetric && myLabelArrowHead || "none") + "," + color;
                labelArrowSplit = labelArrowName.split(",");
                arrowAtLabelAdjust = labelArrowSplit[0] !== "none" && parseInt(labelArrowSplit[1], 10) || 0;
                labelArrowType = arrows[labelArrowName];
                labelArrowDecl = labelArrowType && ("url(#" + labelArrowType + ")");
                if (ufoCatcher) {
                  arrowAtLabelAdjust = -arrowAtLabelAdjust;
                }
              }
              arrowEnd = textEnd + arrowAtLabelAdjust;
              path = svg.createPath().move(arrowEnd, -height);
              if (rowIndex === rightRow) {
                cornerx = to - ufoCatcherMod * arcSlant;
                if (!ufoCatcher && cornerx < arrowEnd + 1) {
                  cornerx = arrowEnd + 1;
                }
                if (smoothArcCurves) {
                  controlx = (ufoCatcher ? cornerx - 2 * ufoCatcherMod * reverseArcControlx : smoothArcSteepness * to + (1 - smoothArcSteepness) * cornerx);
                  endy = rightBox.y + (leftToRight && !arc.equiv ? Configuration.visual.margin.y : rightBox.height / 2);
                  if (Math.abs(-height - endy) < 2 && Math.abs(cornerx - to) < 5) {
                    endy = -height;
                  }
                  path.line(cornerx, -height).curveQ(controlx, -height, to, endy);
                } else {
                  path.line(cornerx, -height).line(to, rightBox.y + (leftToRight && !arc.equiv ? Configuration.visual.margin.y : rightBox.height / 2));
                }
              } else {
                path.line(to, -height);
              }
              svg.path(arcGroup, path, {
                markerEnd: arrowDecl,
                markerStart: labelArrowDecl,
                style: "stroke: " + color,
                strokeDashArray: dashArray
              });
              if (arc.marked) {
                svg.path(shadowGroup, path, {
                  "class": "shadow_EditHighlight_arc",
                  strokeWidth: markedArcStroke,
                  strokeDashArray: dashArray
                });
              }
              if (shadowGroup) {
                svg.path(shadowGroup, path, {
                  "class": "shadow_" + arc.shadowClass,
                  strokeWidth: shadowStroke,
                  strokeDashArray: dashArray
                });
              }
            }
            _results.push(rowIndex++);
          }
          return _results;
        });
        Util.profileEnd("arcs");
        Util.profileStart("fragmentConnectors");
        $.each(data.spans, function(spanNo, span) {
          var connectorNo, from, height, left, leftBox, leftRow, numConnectors, path, right, rightBox, rightRow, to, _results;

          numConnectors = span.fragments.length - 1;
          connectorNo = 0;
          _results = [];
          while (connectorNo < numConnectors) {
            left = span.fragments[connectorNo];
            right = span.fragments[connectorNo + 1];
            leftBox = rowBBox(left);
            rightBox = rowBBox(right);
            leftRow = left.chunk.row.index;
            rightRow = right.chunk.row.index;
            rowIndex = leftRow;
            while (rowIndex <= rightRow) {
              row = rows[rowIndex];
              if (row.chunks.length) {
                row.hasAnnotations = true;
                if (rowIndex === leftRow) {
                  from = leftBox.x + leftBox.width;
                } else {
                  from = sentNumMargin;
                }
                if (rowIndex === rightRow) {
                  to = rightBox.x;
                } else {
                  to = canvasWidth - 2 * Configuration.visual.margin.y;
                }
                height = leftBox.y + leftBox.height - Configuration.visual.margin.y;
                if (roundCoordinates) {
                  height = (height | 0) + 0.5;
                }
                path = svg.createPath().move(from, height).line(to, height);
                svg.path(row.arcs, path, {
                  style: "stroke: " + fragmentConnectorColor,
                  strokeDashArray: fragmentConnectorDashArray
                });
              }
              rowIndex++;
            }
            _results.push(connectorNo++);
          }
          return _results;
        });
        Util.profileEnd("fragmentConnectors");
        Util.profileStart("rows");
        y = Configuration.visual.margin.y;
        sentNumGroup = svg.group({
          "class": "sentnum"
        });
        currentSent = void 0;
        $.each(rows, function(rowId, row) {
          var bgClass, box, link, rowBoxHeight, rowY, sentComment, sentence_hash, shadowRect;

          $.each(row.chunks, function(chunkId, chunk) {
            return $.each(chunk.fragments, function(fragmentId, fragment) {
              if (row.maxSpanHeight < fragment.height) {
                return row.maxSpanHeight = fragment.height;
              }
            });
          });
          if (row.sentence) {
            currentSent = row.sentence;
          }
          rowBoxHeight = Math.max(row.maxArcHeight + 5, row.maxSpanHeight + 1.5);
          if (row.hasAnnotations) {
            rowBoxHeight += rowSpacing + 1.5;
          } else {
            rowBoxHeight -= 5;
          }
          rowBoxHeight += rowPadding;
          bgClass = void 0;
          if (data.markedSent[currentSent]) {
            bgClass = "backgroundHighlight";
          } else if (Configuration.textBackgrounds === "striped") {
            bgClass = "background" + row.backgroundIndex;
          } else {
            bgClass = "background0";
          }
          svg.rect(backgroundGroup, 0, y + sizes.texts.y + sizes.texts.height, canvasWidth, rowBoxHeight + sizes.texts.height + 1, {
            "class": bgClass
          });
          y += rowBoxHeight;
          y += sizes.texts.height;
          row.textY = y - rowPadding;
          if (row.sentence) {
            sentence_hash = new URLHash(coll, doc, {
              focus: [["sent", row.sentence]]
            });
            link = svg.link(sentNumGroup, sentence_hash.getHash());
            text = svg.text(link, sentNumMargin - Configuration.visual.margin.x, y - rowPadding, "" + row.sentence, {
              "data-sent": row.sentence
            });
            sentComment = data.sentComment[row.sentence];
            if (sentComment) {
              box = text.getBBox();
              svg.remove(text);
              shadowRect = svg.rect(sentNumGroup, box.x - rectShadowSize, box.y - rectShadowSize, box.width + 2 * rectShadowSize, box.height + 2 * rectShadowSize, {
                "class": "shadow_" + sentComment.type,
                filter: "url(#Gaussian_Blur)",
                rx: rectShadowRounding,
                ry: rectShadowRounding,
                "data-sent": row.sentence
              });
              text = svg.text(sentNumGroup, sentNumMargin - Configuration.visual.margin.x, y - rowPadding, "" + row.sentence, {
                "data-sent": row.sentence
              });
            }
          }
          rowY = y - rowPadding;
          if (roundCoordinates) {
            rowY = rowY | 0;
          }
          translate(row, 0, rowY);
          return y += Configuration.visual.margin.y;
        });
        y += Configuration.visual.margin.y;
        Util.profileEnd("rows");
        Util.profileStart("chunkFinish");
        currentChunk = void 0;
        lrChunkComp = function(a, b) {
          var ac, bc, startDiff;

          ac = currentChunk.fragments[a];
          bc = currentChunk.fragments[b];
          startDiff = Util.cmp(ac.from, bc.from);
          if (startDiff !== 0) {
            return startDiff;
          } else {
            return Util.cmp(bc.to - bc.from, ac.to - ac.from);
          }
        };
        rlChunkComp = function(a, b) {
          var ac, bc, endDiff;

          ac = currentChunk.fragments[a];
          bc = currentChunk.fragments[b];
          endDiff = Util.cmp(bc.to, ac.to);
          if (endDiff !== 0) {
            return endDiff;
          } else {
            return Util.cmp(bc.to - bc.from, ac.to - ac.from);
          }
        };
        sentenceText = null;
        $.each(data.chunks, function(chunkNo, chunk) {
          var bgColor, c, current, fragment, lightBgColor, nextChunk, nextSpace, o, openFragments, orderedIdx, shrink, spanDesc, stillOpen, xShrink, yShrink, yStartTweak, _results;

          currentChunk = chunk;
          if (chunk.sentence) {
            if (sentenceText) {
              svg.text(textGroup, 0, 0, sentenceText);
            }
            sentenceText = null;
          }
          if (!sentenceText) {
            sentenceText = svg.createText();
          }
          nextChunk = data.chunks[chunkNo + 1];
          nextSpace = (nextChunk ? nextChunk.space : "");
          sentenceText.span(chunk.text + nextSpace, {
            x: chunk.textX,
            y: chunk.row.textY,
            "data-chunk-id": chunk.index
          });
          if (chunk.fragments.length) {
            orderedIdx = [];
            i = chunk.fragments.length - 1;
            while (i >= 0) {
              orderedIdx.push(i);
              i--;
            }
            orderedIdx.sort(lrChunkComp);
            openFragments = [];
            i = 0;
            while (i < orderedIdx.length) {
              current = chunk.fragments[orderedIdx[i]];
              current.nestingHeightLR = 0;
              current.nestingDepthLR = 0;
              stillOpen = [];
              o = 0;
              while (o < openFragments.length) {
                if (openFragments[o].to > current.from) {
                  stillOpen.push(openFragments[o]);
                  openFragments[o].nestingHeightLR++;
                }
                o++;
              }
              openFragments = stillOpen;
              current.nestingDepthLR = openFragments.length;
              openFragments.push(current);
              i++;
            }
            orderedIdx.sort(rlChunkComp);
            openFragments = [];
            i = 0;
            while (i < orderedIdx.length) {
              current = chunk.fragments[orderedIdx[i]];
              current.nestingHeightRL = 0;
              current.nestingDepthRL = 0;
              stillOpen = [];
              o = 0;
              while (o < openFragments.length) {
                if (openFragments[o].from < current.to) {
                  stillOpen.push(openFragments[o]);
                  openFragments[o].nestingHeightRL++;
                }
                o++;
              }
              openFragments = stillOpen;
              current.nestingDepthRL = openFragments.length;
              openFragments.push(current);
              i++;
            }
            i = 0;
            while (i < orderedIdx.length) {
              c = chunk.fragments[orderedIdx[i]];
              c.nestingHeight = (c.nestingHeightLR > c.nestingHeightRL ? c.nestingHeightLR : c.nestingHeightRL);
              c.nestingDepth = (c.nestingDepthLR > c.nestingDepthRL ? c.nestingDepthLR : c.nestingDepthRL);
              i++;
            }
            orderedIdx.sort(function(a, b) {
              return Util.cmp(chunk.fragments[b].nestingHeight, chunk.fragments[a].nestingHeight);
            });
            i = 0;
            _results = [];
            while (i < chunk.fragments.length) {
              fragment = chunk.fragments[orderedIdx[i]];
              spanDesc = spanTypes[fragment.span.type];
              bgColor = (spanDesc && spanDesc.bgColor) || (spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.bgColor) || "#ffffff";
              shrink = 0;
              if (fragment.nestingDepth > 1 && fragment.nestingHeight === 0) {
                shrink = 1;
              } else {
                if (fragment.nestingDepth === 0 && fragment.nestingHeight > 0) {
                  shrink = -1;
                }
              }
              yShrink = shrink * nestingAdjustYStepSize;
              xShrink = shrink * nestingAdjustXStepSize;
              lightBgColor = Util.adjustColorLightness(bgColor, 0.8);
              yStartTweak = 1;
              fragment.highlightPos = {
                x: chunk.textX + fragment.curly.from + xShrink,
                y: chunk.row.textY + sizes.texts.y + yShrink + yStartTweak,
                w: fragment.curly.to - fragment.curly.from - 2 * xShrink,
                h: sizes.texts.height - 2 * yShrink - yStartTweak
              };
              svg.rect(highlightGroup, fragment.highlightPos.x, fragment.highlightPos.y, fragment.highlightPos.w, fragment.highlightPos.h, {
                fill: lightBgColor,
                rx: highlightRounding.x,
                ry: highlightRounding.y
              });
              _results.push(i++);
            }
            return _results;
          }
        });
        if (sentenceText) {
          svg.text(textGroup, 0, 0, sentenceText);
        }
        $.each(textMarkedRows, function(textRowNo, textRowDesc) {
          var markedType, textHighlight;

          textHighlight = svg.rect(highlightGroup, textRowDesc[1] - 2, textRowDesc[0].textY - sizes.fragments.height, textRowDesc[2] - textRowDesc[1] + 4, sizes.fragments.height + 4, {
            fill: "yellow"
          });
          markedType = textRowDesc[3];
          return svg.other(textHighlight, "animate", {
            "data-type": markedType,
            attributeName: "fill",
            values: (markedType === "match" ? highlightMatchSequence : highlightTextSequence),
            dur: highlightDuration,
            repeatCount: "indefinite",
            begin: "indefinite"
          });
        });
        Util.profileEnd("chunkFinish");
        Util.profileStart("finish");
        svg.path(sentNumGroup, svg.createPath().move(sentNumMargin, 0).line(sentNumMargin, y));
        width = maxTextWidth + sentNumMargin + 2 * Configuration.visual.margin.x + 1;
        if (width > canvasWidth) {
          canvasWidth = width;
        }
        $svg.width(canvasWidth);
        $svg.height(y);
        $svgDiv.height(y);
        Util.profileEnd("finish");
        Util.profileEnd("render");
        Util.profileReport();
        drawing = false;
        if (redraw) {
          redraw = false;
          renderDataReal();
        }
        $svg.find("animate").each(function() {
          if (this.beginElement) {
            return this.beginElement();
          }
        });
        return dispatcher.post("doneRendering", [coll, doc, args]);
      };
      renderErrors = {
        unableToReadTextFile: true,
        annotationFileNotFound: true,
        isDirectoryError: true
      };
      renderData = function(sourceData) {
        Util.profileEnd("invoke getDocument");
        if (sourceData && sourceData.exception) {
          if (renderErrors[sourceData.exception]) {
            return dispatcher.post("renderError:" + sourceData.exception, [sourceData]);
          } else {
            return dispatcher.post("unknownError", [sourceData.exception]);
          }
        } else {
          if (sourceData) {
            setSourceDataDefaults(sourceData);
          }
          dispatcher.post("startedRendering", [coll, doc, args]);
          dispatcher.post("spin");
          return setTimeout((function() {
            var e;

            try {
              renderDataReal(sourceData);
            } catch (_error) {
              e = _error;
              drawing = false;
              console.warn("Rendering terminated due to: " + e, e.stack);
              dispatcher.post("renderError: Fatal", [sourceData, e]);
            }
            return dispatcher.post("unspin");
          }), 0);
        }
      };
      renderDocument = function() {
        Util.profileStart("invoke getDocument");
        return dispatcher.post("ajax", [
          {
            action: "getDocument",
            collection: coll,
            document: doc
          }, "renderData", {
            collection: coll,
            document: doc
          }
        ]);
      };
      triggerRender = function() {
        if (svg && ((isRenderRequested && isCollectionLoaded) || requestedData) && Visualizer.areFontsLoaded) {
          isRenderRequested = false;
          if (requestedData) {
            Util.profileClear();
            Util.profileStart("before render");
            return renderData(requestedData);
          } else if (doc.length) {
            Util.profileClear();
            Util.profileStart("before render");
            return renderDocument();
          } else {
            return dispatcher.post(0, "renderError:noFileSpecified");
          }
        }
      };
      requestRenderData = function(sourceData) {
        requestedData = sourceData;
        return triggerRender();
      };
      collectionChanged = function() {
        return isCollectionLoaded = false;
      };
      gotCurrent = function(_coll, _doc, _args, reloadData) {
        coll = _coll;
        doc = _doc;
        args = _args;
        if (reloadData) {
          isRenderRequested = true;
          return triggerRender();
        }
      };
      highlight = void 0;
      highlightArcs = void 0;
      highlightSpans = void 0;
      commentId = void 0;
      onMouseOver = function(evt) {
        var arcEventDescId, arcId, bgColor, comment, commentText, commentType, eventDesc, id, originSpanId, originSpanType, role, span, spanDesc, spanIds, spans, symmetric, target, targetSpanId, targetSpanType;

        target = $(evt.target);
        id = void 0;
        if (id = target.attr("data-span-id")) {
          commentId = id;
          span = data.spans[id];
          dispatcher.post("displaySpanComment", [evt, target, id, span.type, span.attributeText, span.text, span.comment && span.comment.text, span.comment && span.comment.type, span.normalizations]);
          spanDesc = spanTypes[span.type];
          bgColor = (spanDesc && spanDesc.bgColor) || (spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.bgColor) || "#ffffff";
          highlight = [];
          $.each(span.fragments, function(fragmentNo, fragment) {
            return highlight.push(svg.rect(highlightGroup, fragment.highlightPos.x, fragment.highlightPos.y, fragment.highlightPos.w, fragment.highlightPos.h, {
              fill: bgColor,
              opacity: 0.75,
              rx: highlightRounding.x,
              ry: highlightRounding.y
            }));
          });
          if (that.arcDragOrigin) {
            target.parent().addClass("highlight");
          } else {
            highlightArcs = $svg.find("g[data-from=\"" + id + "\"], g[data-to=\"" + id + "\"]").addClass("highlight");
            spans = {};
            spans[id] = true;
            spanIds = [];
            $.each(span.incoming, function(arcNo, arc) {
              return spans[arc.origin] = true;
            });
            $.each(span.outgoing, function(arcNo, arc) {
              return spans[arc.target] = true;
            });
            $.each(spans, function(spanId, dummy) {
              return spanIds.push("rect[data-span-id=\"" + spanId + "\"]");
            });
            highlightSpans = $svg.find(spanIds.join(", ")).parent().addClass("highlight");
          }
          return forceRedraw();
        } else if (!that.arcDragOrigin && (id = target.attr("data-arc-role"))) {
          originSpanId = target.attr("data-arc-origin");
          targetSpanId = target.attr("data-arc-target");
          role = target.attr("data-arc-role");
          symmetric = relationTypesHash && relationTypesHash[role] && relationTypesHash[role].properties && relationTypesHash[role].properties.symmetric;
          arcEventDescId = target.attr("data-arc-ed");
          commentText = "";
          commentType = "";
          arcId = void 0;
          if (arcEventDescId) {
            eventDesc = data.eventDescs[arcEventDescId];
            comment = eventDesc.comment;
            if (comment) {
              commentText = comment.text;
              commentType = comment.type;
              if (commentText === "" && commentType) {
                commentText = commentType;
              }
            }
            if (eventDesc.relation) {
              arcId = arcEventDescId;
            }
          }
          originSpanType = data.spans[originSpanId].type || "";
          targetSpanType = data.spans[targetSpanId].type || "";
          dispatcher.post("displayArcComment", [evt, target, symmetric, arcId, originSpanId, originSpanType, role, targetSpanId, targetSpanType, commentText, commentType]);
          highlightArcs = $svg.find("g[data-from=\"" + originSpanId + "\"][data-to=\"" + targetSpanId + "\"]").addClass("highlight");
          return highlightSpans = $($svg).find("rect[data-span-id=\"" + originSpanId + "\"], rect[data-span-id=\"" + targetSpanId + "\"]").parent().addClass("highlight");
        } else if (id = target.attr("data-sent")) {
          comment = data.sentComment[id];
          if (comment) {
            return dispatcher.post("displaySentComment", [evt, target, comment.text, comment.type]);
          }
        }
      };
      onMouseOut = function(evt) {
        var target;

        target = $(evt.target);
        target.removeClass("badTarget");
        dispatcher.post("hideComment");
        if (highlight) {
          $.each(highlight, function() {
            return svg.remove(this);
          });
          highlight = undefined;
        }
        if (highlightSpans) {
          highlightArcs.removeClass("highlight");
          highlightSpans.removeClass("highlight");
          highlightSpans = undefined;
        }
        return forceRedraw();
      };
      setAbbrevs = function(_abbrevsOn) {
        Configuration.abbrevsOn = _abbrevsOn;
        return dispatcher.post("configurationChanged");
      };
      setTextBackgrounds = function(_textBackgrounds) {
        Configuration.textBackgrounds = _textBackgrounds;
        return dispatcher.post("configurationChanged");
      };
      setLayoutDensity = function(_density) {
        if (_density < 2) {
          Configuration.visual.margin = {
            x: 1,
            y: 0
          };
          Configuration.visual.boxSpacing = 1;
          Configuration.visual.curlyHeight = 1;
          Configuration.visual.arcSpacing = 7;
          Configuration.visual.arcStartHeight = 18;
        } else if (_density > 2) {
          Configuration.visual.margin = {
            x: 2,
            y: 1
          };
          Configuration.visual.boxSpacing = 3;
          Configuration.visual.curlyHeight = 6;
          Configuration.visual.arcSpacing = 12;
          Configuration.visual.arcStartHeight = 23;
        } else {
          Configuration.visual.margin = {
            x: 2,
            y: 1
          };
          Configuration.visual.boxSpacing = 1;
          Configuration.visual.curlyHeight = 4;
          Configuration.visual.arcSpacing = 9;
          Configuration.visual.arcStartHeight = 19;
        }
        return dispatcher.post("configurationChanged");
      };
      setSvgWidth = function(_width) {
        $svgDiv.width(_width);
        if (Configuration.svgWidth !== _width) {
          Configuration.svgWidth = _width;
          return dispatcher.post("configurationChanged");
        }
      };
      $svgDiv = $($svgDiv).hide();
      registerHandlers = function(element, events) {
        return $.each(events, function(eventNo, eventName) {
          return element.bind(eventName, function(evt) {
            return dispatcher.post(eventName, [evt], "all");
          });
        });
      };
      registerHandlers($svgDiv, ["mouseover", "mouseout", "mousemove", "mouseup", "mousedown", "dragstart", "dblclick", "click"]);
      registerHandlers($(document), ["keydown", "keypress", "touchstart", "touchend"]);
      registerHandlers($(window), ["resize"]);
      $svgDiv.svg({
        onLoad: function(_svg) {
          that.svg = svg = _svg;
          $svg = $(svg._svg);
          return triggerRender();
        }
      });
      loadSpanTypes = function(types) {
        return $.each(types, function(typeNo, type) {
          var children;

          if (type) {
            spanTypes[type.type] = type;
            children = type.children;
            if (children && children.length) {
              return loadSpanTypes(children);
            }
          }
        });
      };
      loadAttributeTypes = function(response_types) {
        var processed;

        processed = {};
        $.each(response_types, function(aTypeNo, aType) {
          var i, values;

          processed[aType.type] = aType;
          values = [];
          for (i in aType.values) {
            if (aType.values.hasOwnProperty(i)) {
              values.push(i);
            }
          }
          if (values.length === 1) {
            return aType.bool = values[0];
          }
        });
        return processed;
      };
      loadRelationTypes = function(relation_types) {
        return $.each(relation_types, function(relTypeNo, relType) {
          var children;

          if (relType) {
            relationTypesHash[relType.type] = relType;
            children = relType.children;
            if (children && children.length) {
              return loadRelationTypes(children);
            }
          }
        });
      };
      collectionLoaded = function(response) {
        var arcBundle;

        if (!response.exception) {
          setCollectionDefaults(response);
          eventAttributeTypes = loadAttributeTypes(response.event_attribute_types);
          entityAttributeTypes = loadAttributeTypes(response.entity_attribute_types);
          spanTypes = {};
          loadSpanTypes(response.entity_types);
          loadSpanTypes(response.event_types);
          loadSpanTypes(response.unconfigured_types);
          relationTypesHash = {};
          loadRelationTypes(response.relation_types);
          loadRelationTypes(response.unconfigured_types);
          $.each(response.relation_types, function(relTypeNo, relType) {
            return relationTypesHash[relType.type] = relType;
          });
          arcBundle = (response.visual_options || {}).arc_bundle || "none";
          collapseArcs = arcBundle === "all";
          collapseArcSpace = arcBundle !== "none";
          dispatcher.post("spanAndAttributeTypesLoaded", [spanTypes, entityAttributeTypes, eventAttributeTypes, relationTypesHash]);
          isCollectionLoaded = true;
          return triggerRender();
        } else {

        }
      };
      isReloadOkay = function() {
        return !drawing;
      };
      if (!Visualizer.areFontsLoaded) {
        webFontConfig = {
          custom: {
            families: ["Astloch", "PT Sans Caption", "Liberation Sans"],
            urls: (webFontURLs !== undefined ? webFontURLs : ["static/fonts/Astloch-Bold.ttf", "static/fonts/PT_Sans-Caption-Web-Regular.ttf", "static/fonts/Liberation_Sans-Regular.ttf"])
          },
          active: proceedWithFonts,
          inactive: proceedWithFonts,
          fontactive: function(fontFamily, fontDescription) {},
          fontloading: function(fontFamily, fontDescription) {}
        };
        WebFont.load(webFontConfig);
        setTimeout((function() {
          if (!Visualizer.areFontsLoaded) {
            console.error("Timeout in loading fonts");
            return proceedWithFonts();
          }
        }), fontLoadTimeout);
      }
      return dispatcher.on("collectionChanged", collectionChanged).on("collectionLoaded", collectionLoaded).on("renderData", renderData).on("triggerRender", triggerRender).on("requestRenderData", requestRenderData).on("isReloadOkay", isReloadOkay).on("resetData", resetData).on("abbrevs", setAbbrevs).on("textBackgrounds", setTextBackgrounds).on("layoutDensity", setLayoutDensity).on("svgWidth", setSvgWidth).on("current", gotCurrent).on("clearSVG", clearSVG).on("mouseover", onMouseOver).on("mouseout", onMouseOut);
    };
    Visualizer.areFontsLoaded = false;
    proceedWithFonts = function() {
      Visualizer.areFontsLoaded = true;
      return Dispatcher.post("triggerRender");
    };
    return Visualizer;
  })(jQuery, window);

}).call(this);
